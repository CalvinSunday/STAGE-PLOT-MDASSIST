
<div id="stageplot-app" class="sp-app" tabindex="0">
  <div class="sp-toolbar">
    <div class="sp-toolbarLeft">
      <button id="sp-gridBtn" class="sp-btn" aria-pressed="true">Grid: On</button>

      <label class="sp-check">
        <input id="sp-snap" type="checkbox" checked>
        Snap
      </label>

      <label class="sp-label">
        Grid size
        <input id="sp-gridSize" type="number" min="0.1" step="0.1" value="1">
      </label>

      <span class="sp-sep"></span>

      <button id="sp-addTextBtn" class="sp-btn">Add Text</button>

      <label class="sp-btn sp-fileBtn">
        Add Image
        <input id="sp-addImageInput" type="file" accept="image/*">
      </label>

      <span class="sp-sep"></span>

      <button id="sp-cableModeBtn" class="sp-btn" aria-pressed="false">Cable Tool: Off</button>
      <button id="sp-cableFinishBtn" class="sp-btn" disabled>Finish Cable</button>

      <label class="sp-label">
        Cable
        <input id="sp-cableColor" type="color" value="#111111">
      </label>

      <label class="sp-label">
        Width
        <input id="sp-cableWidth" type="number" min="1" max="20" step="1" value="3" style="width:64px">
      </label>
    </div>

    <div class="sp-toolbarRight">
      <button id="sp-undoBtn" class="sp-btn">Undo</button>
      <button id="sp-redoBtn" class="sp-btn">Redo</button>

      <span class="sp-sep"></span>

      <button id="sp-zoomOut" class="sp-btn" title="Zoom Out (stage)">− Zoom Out</button>
      <button id="sp-zoomIn" class="sp-btn" title="Zoom In (stage)">+ Zoom In</button>
      <button id="sp-fullscreenBtn" class="sp-btn">Fullscreen</button>
      <button id="sp-fullLibToggle" class="sp-btn" style="display:none">Library</button>
      <button id="sp-fullInspectorToggle" class="sp-btn" style="display:none">Inspector</button>

      <span class="sp-sep"></span>

      <button id="sp-saveBtn" class="sp-btn">Save JSON</button>
      <label class="sp-btn sp-fileBtn">
        Load JSON
        <input id="sp-loadInput" type="file" accept="application/json">
      </label>

      <span class="sp-sep"></span>

      <button id="sp-exportSvgBtn" class="sp-btn">Export SVG</button>
      <button id="sp-exportPngBtn" class="sp-btn">Export PNG</button>
    </div>
  </div>

  <div class="sp-keys" id="sp-keys">
    <div style="display:flex; gap:16px; align-items:center; padding:8px 12px;">
      <div style="font-weight:700;">Keys</div>
      <div>• <b>C</b> toggle cable tool • Cable Tool On → click to place points → Double-click / Enter / Finish Cable to commit</div>
      <div>• <b>R</b> rotate clockwise • <b>Shift+R</b> counter-clockwise</div>
      <div>• <b>+</b>/<b>-</b> scale up/down</div>
      <div>• <b>[</b>/<b>]</b> send back / bring forward • <b>Shift+[</b>/<b>Shift+]</b> to back / to front</div>
      <div>• <b>D</b> duplicate • <b>G</b> group • <b>Shift+G</b> ungroup</div>
      <div>• <b>L</b> lock/unlock selection • <b>Del</b> delete</div>
      <div>• <b>Ctrl/Cmd+Z</b> undo • <b>Ctrl/Cmd+Shift+Z</b> redo</div>
      <div class="sp-muted" style="margin-left:auto;">Locked items are click-through; unlock from Layers.</div>
    </div>
  </div>

  <div class="sp-body">
    <aside class="sp-library">
      <div class="sp-libhead">
        <div style="display:flex; gap:8px; align-items:center;">
            <div class="sp-libtitle">Library</div>
            <span class="sp-collapsedLabel" style="display:none; font-weight:700; margin-left:8px;">Library</span>
          <button id="sp-libToggle" class="sp-btn sp-mini" aria-pressed="false"><span class="sp-libToggleLabel">Hide</span> <span class="sp-chev">▾</span></button>
        </div>
        <input id="sp-search" class="sp-search" placeholder="Search…" />
      </div>

      <div id="sp-libgrid" class="sp-libgrid"></div>

      <div id="sp-libResizer" class="sp-lib-resizer" title="Drag to resize library"></div>
    </aside>

    <main class="sp-main">
      <div class="sp-stageTop">
        <div class="sp-row">
          <label class="sp-label">Units
            <select id="sp-units">
              <option value="ft" selected>ft</option>
              <option value="m">m</option>
            </select>
          </label>

          <label class="sp-label">W
            <input id="sp-w" type="number" min="1" step="0.5" value="40" style="width:90px">
          </label>

          <label class="sp-label">H
            <input id="sp-h" type="number" min="1" step="0.5" value="23" style="width:90px">
          </label>

          <button id="sp-resizeBtn" class="sp-btn">Resize Stage</button>

          <div id="sp-status" class="sp-status">No selection</div>
        </div>
      </div>

      <div class="sp-stageGrid">
        <div class="sp-canvasWrap">
          <svg id="sp-svg" class="sp-svg" viewBox="0 0 1200 700" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <pattern id="sp-grid" width="30" height="30" patternUnits="userSpaceOnUse">
                <path d="M 30 0 L 0 0 0 30" fill="none" stroke="rgba(0,0,0,0.10)" stroke-width="1"/>
              </pattern>
              <filter id="sp-shadow" x="-20%" y="-20%" width="140%" height="140%">
                <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="rgba(0,0,0,0.20)"/>
              </filter>
            </defs>

            <rect id="sp-bg" x="0" y="0" width="1200" height="700" fill="white"/>
            <rect id="sp-gridRect" x="0" y="0" width="1200" height="700" fill="url(#sp-grid)"/>

            <g id="sp-guides" pointer-events="none"></g>
            <g id="sp-items"></g>
            <g id="sp-cableDraft"></g>

            <g id="sp-overlay">
              <g id="sp-selection" visibility="hidden" pointer-events="none">
                <rect id="sp-selRect" x="0" y="0" width="0" height="0" fill="none" stroke="rgba(0,120,255,0.95)" stroke-width="2" stroke-dasharray="6 6"/>
              </g>
              <g id="sp-verts" pointer-events="auto"></g>
            </g>
          </svg>
        </div>

        <aside class="sp-sidepanel">
          <div class="sp-panelSection">
            <div class="sp-panelHeader">Inspector</div>

            <div class="sp-inspectorActions">
              <button id="sp-sendBackAll" class="sp-btn sp-mini">To Back</button>
              <button id="sp-sendBack" class="sp-btn sp-mini">Back</button>
              <button id="sp-bringFwd" class="sp-btn sp-mini">Forward</button>
              <button id="sp-bringFront" class="sp-btn sp-mini">To Front</button>
            </div>

            <div class="sp-inspectorActions">
              <button id="sp-duplicateBtn" class="sp-btn sp-mini">Duplicate</button>
              <button id="sp-groupBtn" class="sp-btn sp-mini">Group</button>
              <button id="sp-ungroupBtn" class="sp-btn sp-mini">Ungroup</button>
            </div>

            <div class="sp-inspectorActions">
              <button id="sp-lockBtn" class="sp-btn sp-mini" aria-pressed="false">Lock</button>
              <button id="sp-deleteBtn" class="sp-btn sp-mini">Delete</button>
              <button id="sp-clearSel" class="sp-btn sp-mini">Clear</button>
            </div>

            <div id="sp-inspectorFields" class="sp-fields"></div>
          </div>

          <div class="sp-panelSection">
            <div class="sp-panelHeader">Layers</div>
            <div id="sp-layerList" class="sp-layerList"></div>
          </div>
        </aside>
      </div>
    </main>
  </div>
</div>

<style>
  /* --- Layout stability / best-practice defaults --- */
  .sp-app, .sp-app * { box-sizing: border-box; }
  .sp-app { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#111; outline:none;
    /* Keep the stage canvas from jumping when the library is open */
    display:flex; flex-direction:column;
    /* make the app fill the viewport so the canvas is visible without page scroll */
    min-height: 100vh;
  }
  .sp-toolbar { display:flex; gap:12px; justify-content:space-between; align-items:center; padding:10px; border:1px solid #e5e7eb; background:#fafafa; border-radius:10px; }
  .sp-keys { position:sticky; top:0; z-index:10; background:#fff; border-bottom:1px solid #eee; }
  .sp-keys div { font-size:13px; }
  .sp-toolbarLeft, .sp-toolbarRight { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .sp-body { margin-top:10px; display:grid; grid-template-columns: 1fr; grid-template-rows: 320px 1fr; gap:10px;
    flex:1 1 auto; min-height:0; }

  .sp-library { border:1px solid #e5e7eb; border-radius:10px; background:#fff; overflow:hidden; display:flex; flex-direction:column; min-height:0; height:var(--sp-lib-height,320px); width:100%; transition: height .22s ease; }

  .sp-libhead { display:flex; gap:8px; align-items:center; padding:10px; border-bottom:1px solid #f0f0f0; background:#fafafa; }
  .sp-libToggleLabel { margin-right:6px; }
  .sp-chev { display:inline-block; transition: transform .2s ease; font-size:12px; }
  .sp-libtitle { font-weight:700; }
  .sp-search { flex:1; border:1px solid #e5e7eb; border-radius:8px; padding:8px 10px; }
  .sp-libgrid { padding:10px; display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap:10px;
    flex:1 1 auto; min-height:0; overflow:auto; }

  .sp-lib-resizer { height:8px; cursor:row-resize; background:transparent; }
  .sp-lib-resizer:hover { background:linear-gradient(90deg, rgba(0,0,0,0.03), rgba(0,0,0,0.06)); }

  /* Compact library cards */
  .sp-libgrid { padding:8px; display:grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap:8px; }
  .sp-card { border:1px solid #e5e7eb; border-radius:8px; padding:6px; cursor:pointer; user-select:none; background:#fff; transition: transform .05s ease; display:flex; flex-direction:column; align-items:center; }
  .sp-card:hover { transform: translateY(-2px); }
  .sp-thumb { width:44px; height:44px; display:flex; align-items:center; justify-content:center; margin:4px 0; }
  .sp-name { margin-top:6px; font-size:11px; text-align:center; color:#111; max-width:72px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .sp-help { padding:10px; border-top:1px solid #f0f0f0; font-size:12px; color:#111; }
  .sp-muted { color:#6b7280; }

  .sp-main { border:1px solid #e5e7eb; border-radius:10px; background:#fff; overflow:hidden; display:flex; flex-direction:column; min-height:0; height:100%; min-width:0; }

  .sp-stageTop { padding:10px; border-bottom:1px solid #f0f0f0; background:#fafafa; }
  .sp-row { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .sp-stageGrid { display:flex; flex-direction:column; flex:1 1 auto; min-height:0; }
  .sp-canvasWrap { flex:1 1 auto; min-height:0; padding:10px; overflow:auto; border-right:none; border-bottom:1px solid #f0f0f0; background:#f3f4f6; }
  /* Make the area around the canvas slightly darker to separate it from the white canvas */
  .sp-canvasWrap { background:#e6e9ef; }
  /* canvas should fill available space and not be squished by library resize */
  :root { --sp-canvas-min-height: 420px; }
  .sp-canvasWrap { display:flex; flex-direction:column; }
  .sp-svg { background:#ffffff; border:1px solid #d1d5db; border-radius:10px; width:100%; height:100%; display:block; box-shadow: 0 2px 6px rgba(0,0,0,0.04); }

  /* Fullscreen: force canvas-first layout (hide sidepanel) and keep toolbar available; show floating draggable library */
  #stageplot-app.sp-fullscreen .sp-sidepanel { display:none !important; }
  #stageplot-app.sp-fullscreen .sp-toolbar { position:fixed; top:8px; left:8px; right:8px; z-index:9999; border-radius:10px; }
  /* Make the main canvas area occupy the rest of the viewport */
  #stageplot-app.sp-fullscreen .sp-stageGrid { position:fixed; top:64px; left:0; right:0; bottom:0; padding:20px; box-sizing:border-box; background:#0b1220; display:flex; align-items:center; justify-content:center; z-index:9998; }
  #stageplot-app.sp-fullscreen .sp-canvasWrap { width:100%; height:100%; padding:0; background:transparent; display:flex; align-items:center; justify-content:center; }
  /* SVG: let JS compute precise pixel size to fully use available area */
  #stageplot-app.sp-fullscreen .sp-svg { width:auto !important; height:auto !important; max-width:none !important; max-height:none !important; box-shadow: 0 6px 30px rgba(0,0,0,0.6); background:#ffffff; border-radius:10px; }
  /* Floating library in fullscreen (draggable) */
  #stageplot-app.sp-fullscreen .sp-library { display:block !important; position:fixed; left:20px; top:80px; width:260px; max-height:calc(100vh - 140px); overflow:auto; background:rgba(255,255,255,0.96); z-index:10001; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.28); cursor:grab; }
  #stageplot-app.sp-fullscreen .sp-library.dragging { cursor:grabbing; opacity:0.98; }

  /* Floating inspector in fullscreen */
  #stageplot-app.sp-fullscreen .sp-sidepanel.floating { display:block !important; position:fixed; right:20px; top:80px; width:320px; max-height:calc(100vh - 140px); overflow:auto; background:rgba(255,255,255,0.98); z-index:10002; border-radius:8px; box-shadow:0 10px 40px rgba(0,0,0,0.36); cursor:grab; }
  #stageplot-app.sp-fullscreen .sp-sidepanel.floating.dragging { cursor:grabbing; opacity:0.99; }
  #stageplot-app.sp-fullscreen .sp-sidepanel.floating.minimized { height:48px; overflow:visible; }
  .sp-sidepanel .sp-float-hdr { display:none; align-items:center; gap:8px; padding:8px 10px; border-bottom:1px solid rgba(0,0,0,0.06); background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(250,250,250,0.9)); cursor:grab; }
  #stageplot-app.sp-fullscreen .sp-sidepanel.floating .sp-float-hdr { display:flex; }
  .sp-sidepanel .sp-float-hdr .sp-title { font-weight:700; flex:1; }
  .sp-sidepanel .sp-float-hdr .sp-float-btn { border:0; background:transparent; padding:6px 8px; border-radius:6px; cursor:pointer; }
  .sp-sidepanel .sp-float-btn:hover { background:rgba(0,0,0,0.04); }
  .sp-canvasWrap { min-height: var(--sp-canvas-min-height); }
  /* Cable tool cursor: tiny power-plug icon */
  .sp-cable-mode .sp-canvasWrap, .sp-cable-mode .sp-svg { cursor: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><rect x='6' y='1' width='4' height='6' fill='%23111'/><rect x='5' y='7' width='6' height='6' rx='1' fill='%23111'/><rect x='5.5' y='2' width='1' height='2' fill='%23fff'/><rect x='9.5' y='2' width='1' height='2' fill='%23fff'/></svg>") 8 8, crosshair; }
  .sp-sidepanel { flex:0 0 auto; padding:10px; border-top:1px solid #f0f0f0; background:#fff; display:grid; grid-template-columns: 1.2fr 0.8fr; grid-template-rows: 1fr; gap:10px; height:260px; min-height:180px; max-height:60vh; overflow:auto; resize:vertical; }
  .sp-panelSection { border:1px solid #e5e7eb; border-radius:10px; padding:10px; margin-bottom:0; min-height:0; overflow:auto; }
  .sp-panelHeader { font-weight:700; margin-bottom:10px; }
  .sp-inspectorActions { display:flex; flex-wrap:wrap; gap:8px; margin-bottom:10px; }
  .sp-fields { display:flex; flex-direction:column; gap:10px; }
  .sp-field { display:flex; flex-direction:column; gap:6px; }
  .sp-field textarea { width:100%; min-height:70px; resize:vertical; border:1px solid #e5e7eb; border-radius:8px; padding:8px; font-family:inherit; }
  .sp-inline { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
  .sp-status { margin-left:auto; color:#111; font-size:12px; padding:6px 10px; border:1px solid #e5e7eb; border-radius:999px; background:#fff; }

  .sp-btn { border:1px solid #e5e7eb; background:#fff; border-radius:10px; padding:8px 10px; cursor:pointer; font-size:13px; }
  .sp-btn:hover { background:#f3f4f6; }
  .sp-btn:disabled { opacity:0.5; cursor:not-allowed; }
  .sp-mini { padding:6px 8px; border-radius:8px; font-size:12px; }
  .sp-label { display:flex; gap:6px; align-items:center; font-size:13px; }
  .sp-label input, .sp-label select { border:1px solid #e5e7eb; border-radius:8px; padding:6px 8px; font-size:13px; }
  .sp-check { display:flex; gap:6px; align-items:center; font-size:13px; }
  .sp-sep { width:1px; height:26px; background:#e5e7eb; display:inline-block; }

  .sp-fileBtn { position:relative; overflow:hidden; }
  .sp-fileBtn input[type="file"] { position:absolute; inset:0; opacity:0; cursor:pointer; }

  .sp-layerList { display:flex; flex-direction:column; gap:6px; }
  .sp-layerRow { display:flex; justify-content:space-between; gap:10px; align-items:center; padding:8px; border:1px solid #e5e7eb; border-radius:10px; cursor:pointer; background:#fff; }
  .sp-layerRow.selected { outline:2px solid rgba(0,120,255,0.35); border-color: rgba(0,120,255,0.65); }
  .sp-layerLeft { display:flex; flex-direction:column; gap:2px; min-width: 0; }
  .sp-layerName { font-size:13px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 190px; }
  .sp-layerMeta { font-size:11px; color:#6b7280; }
  .sp-layerBtns { display:flex; gap:6px; align-items:center; flex-shrink:0; }
  .sp-groupRow { background:#fafafa; }
  .sp-childRow { background:#fff; margin-left:12px; }

  /* Library collapse (library becomes a small header row) */
  #stageplot-app.sp-lib-collapsed .sp-body { grid-template-rows: 56px 1fr; }
  #stageplot-app.sp-lib-collapsed .sp-libtitle,
  #stageplot-app.sp-lib-collapsed .sp-search,
  #stageplot-app.sp-lib-collapsed .sp-libgrid,
  #stageplot-app.sp-lib-collapsed .sp-help { display:none; }
  #stageplot-app.sp-lib-collapsed .sp-library { min-height:56px; height:56px; }
  #stageplot-app.sp-lib-collapsed .sp-libhead { justify-content:center; }
  #stageplot-app.sp-lib-collapsed #sp-libToggle .sp-chev { transform: rotate(180deg); }

  @media (max-width: 980px) {
    .sp-body { grid-template-columns: 1fr; }

    .sp-sidepanel { grid-template-columns: 1fr; height:auto; max-height:none; resize:none; overflow:visible; }
    .sp-panelSection { overflow:visible; }
  }
</style>

<script>

(() => {
  "use strict";
  // ============================================================
  // Stage Plot Creator (single-file app)
  // ============================================================

  // ---------- DOM ----------
  const root = document.getElementById("stageplot-app");
  if (!root) return;

  const els = {
    svg: document.getElementById("sp-svg"),
    items: document.getElementById("sp-items"),
    guides: document.getElementById("sp-guides"),
    verts: document.getElementById("sp-verts"),
    cableDraft: document.getElementById("sp-cableDraft"),
    gridRect: document.getElementById("sp-gridRect"),
    gridPattern: document.getElementById("sp-grid"),
    gridBtn: document.getElementById("sp-gridBtn"),
    snap: document.getElementById("sp-snap"),
    gridSize: document.getElementById("sp-gridSize"),
    libgrid: document.getElementById("sp-libgrid"),
    search: document.getElementById("sp-search"),
    w: document.getElementById("sp-w"),
    h: document.getElementById("sp-h"),
    resizeBtn: document.getElementById("sp-resizeBtn"),
    saveBtn: document.getElementById("sp-saveBtn"),
    loadInput: document.getElementById("sp-loadInput"),
    exportSvgBtn: document.getElementById("sp-exportSvgBtn"),
    exportPngBtn: document.getElementById("sp-exportPngBtn"),
    selection: document.getElementById("sp-selection"),
    selRect: document.getElementById("sp-selRect"),
    status: document.getElementById("sp-status"),
    clearSel: document.getElementById("sp-clearSel"),
    deleteBtn: document.getElementById("sp-deleteBtn"),
    lockBtn: document.getElementById("sp-lockBtn"),
    bringFwd: document.getElementById("sp-bringFwd"),
    sendBack: document.getElementById("sp-sendBack"),
    bringFront: document.getElementById("sp-bringFront"),
    sendBackAll: document.getElementById("sp-sendBackAll"),
    duplicateBtn: document.getElementById("sp-duplicateBtn"),
    groupBtn: document.getElementById("sp-groupBtn"),
    ungroupBtn: document.getElementById("sp-ungroupBtn"),
    inspectorFields: document.getElementById("sp-inspectorFields"),
    addTextBtn: document.getElementById("sp-addTextBtn"),
    addImageInput: document.getElementById("sp-addImageInput"),
    cableModeBtn: document.getElementById("sp-cableModeBtn"),
    cableFinishBtn: document.getElementById("sp-cableFinishBtn"),
    cableColor: document.getElementById("sp-cableColor"),
    cableWidth: document.getElementById("sp-cableWidth"),
    layerList: document.getElementById("sp-layerList"),
    zoomIn: document.getElementById("sp-zoomIn"),
    zoomOut: document.getElementById("sp-zoomOut"),
    fullscreenBtn: document.getElementById("sp-fullscreenBtn"),
    fullLibToggle: document.getElementById("sp-fullLibToggle"),
    units: document.getElementById("sp-units"),
    qaScaleDown: document.getElementById("sp-qaScaleDown"),
    qaScaleUp: document.getElementById("sp-qaScaleUp"),
    qaFontDown: document.getElementById("sp-qaFontDown"),
    qaFontUp: document.getElementById("sp-qaFontUp"),
    qaWDown: document.getElementById("sp-qaWDown"),
    qaWUp: document.getElementById("sp-qaWUp"),
    qaHDown: document.getElementById("sp-qaHDown"),
    qaHUp: document.getElementById("sp-qaHUp"),
    undoBtn: document.getElementById("sp-undoBtn"),
    redoBtn: document.getElementById("sp-redoBtn"),
    libToggle: document.getElementById("sp-libToggle"),
  };

  // ---------- Units (stage accuracy) ----------
  const PX_PER_FT = 30;         // SVG units per foot (so 40ft ≈ 1200)
  const FT_PER_M = 3.28084;

  function pxPerUnit() {
    return (els.units && els.units.value === "m") ? (PX_PER_FT * FT_PER_M) : PX_PER_FT;
  }
  function unitsToPx(u) { return u * pxPerUnit(); }
  function pxToUnits(px) { return px / pxPerUnit(); }

  // ---------- SVG library helpers ----------
  function makeTintableSvgGroup(svg) {
    // Convert outer <svg> into <g> then replace black fills/strokes with currentColor
    let s = String(svg || "");
    s = s.replace(/<svg\b/g, "<g").replace(/<\/svg>/g, "</g>");
    // rgba(0,0,0,a) => currentColor with opacity preserved
    s = s.replace(/fill="rgba\(\s*0\s*,\s*0\s*,\s*0\s*,\s*([0-9.]+)\s*\)"/gi, 'fill="currentColor" fill-opacity="$1"');
    s = s.replace(/stroke="rgba\(\s*0\s*,\s*0\s*,\s*0\s*,\s*([0-9.]+)\s*\)"/gi, 'stroke="currentColor" stroke-opacity="$1"');
    // hex/keyword black
    s = s.replace(/fill="#(?:000000|000|111111)"/gi, 'fill="currentColor"');
    s = s.replace(/stroke="#(?:000000|000|111111)"/gi, 'stroke="currentColor"');
    s = s.replace(/fill="black"/gi, 'fill="currentColor"');
    s = s.replace(/stroke="black"/gi, 'stroke="currentColor"');
    return s;
  }

  function parseViewBox(viewBox) {
    if (!viewBox) return null;
    const parts = String(viewBox).trim().split(/[\s,]+/).map(Number);
    if (parts.length !== 4 || parts.some(n => !Number.isFinite(n))) return null;
    return { x: parts[0], y: parts[1], w: parts[2], h: parts[3] };
  }

  function extractSvgInner(svgText) {
    try {
      const parser = new DOMParser();
      const doc = parser.parseFromString(String(svgText || ""), "image/svg+xml");
      const svg = doc.querySelector("svg");
      if (!svg) return null;
      let vb = parseViewBox(svg.getAttribute("viewBox"));
      if (!vb) {
        const w = parseFloat(svg.getAttribute("width"));
        const h = parseFloat(svg.getAttribute("height"));
        if (Number.isFinite(w) && Number.isFinite(h)) vb = { x: 0, y: 0, w, h };
      }
      return { inner: svg.innerHTML || "", vb };
    } catch (err) {
      return null;
    }
  }

  function buildExternalIconSvg(svgText) {
    const parsed = extractSvgInner(svgText);
    if (!parsed || !parsed.inner) return null;
    const vb = parsed.vb || { x: 0, y: 0, w: 70, h: 70 };
    const vbW = Math.max(1, vb.w || 70);
    const vbH = Math.max(1, vb.h || 70);
    const vbX = vb.x || 0;
    const vbY = vb.y || 0;
    const scale = 70 / Math.max(vbW, vbH);
    const cx = vbX + vbW / 2;
    const cy = vbY + vbH / 2;
    const content = `<g transform="translate(35 35) scale(${scale}) translate(${-cx} ${-cy})">${parsed.inner}</g>`;
    const thumbSvg = `<svg width="64" height="64" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">${content}</svg>`;
    const svgGroup = makeTintableSvgGroup(`<svg width="70" height="70" viewBox="0 0 70 70" xmlns="http://www.w3.org/2000/svg">${content}</svg>`);
    return { thumbSvg, svgGroup };
  }

  function hashToIndex(str, mod) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return Math.abs(h) % mod;
  }

  const DEFAULT_ICON_COLORS = [
    "#0f172a", // slate-950
    "#111827", // gray-ish
    "#1f2937",
    "#27272a",
    "#1b1b1b",
    "#2c2c2c",
  ];

  function defaultIconColor(iconId) {
    return DEFAULT_ICON_COLORS[hashToIndex(iconId, DEFAULT_ICON_COLORS.length)];
  }

  // ============================================================
  // ICON SVGs
  // ============================================================
  function baseBox(label) {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="14" width="46" height="42" rx="8" fill="rgba(0,0,0,0.82)"/>
      <text x="35" y="41" text-anchor="middle" font-size="11" fill="rgba(255,255,255,0.92)">${label}</text>
    </svg>`;
  }

  // Simple shapes for library
  function squareThumbSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="16" y="16" width="38" height="38" rx="6"
            fill="none" stroke="rgba(0,0,0,0.85)" stroke-width="4"/>
    </svg>`;
  }
  function circleThumbSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <circle cx="35" cy="35" r="19"
              fill="none" stroke="rgba(0,0,0,0.85)" stroke-width="4"/>
    </svg>`;
  }
  function textThumbSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="20" width="46" height="30" rx="8" fill="rgba(0,0,0,0.10)" stroke="rgba(0,0,0,0.55)" stroke-width="2"/>
      <text x="35" y="41" text-anchor="middle" font-size="18" fill="rgba(0,0,0,0.85)">T</text>
    </svg>`;
  }

  // Basics
  function wedgeSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <path d="M15 45 L55 30 L60 50 L20 60 Z" fill="rgba(0,0,0,0.78)"/>
      <path d="M20 58 L58 48" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
    </svg>`;
  }
  function ampSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="18" y="18" width="34" height="34" rx="6" fill="rgba(0,0,0,0.82)"/>
      <g opacity="0.35" stroke="white">
        <path d="M22 24 H48" />
        <path d="M22 30 H48" />
        <path d="M22 36 H48" />
        <path d="M22 42 H48" />
        <path d="M22 48 H48" />
      </g>
    </svg>`;
  }
  function drumSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <ellipse cx="35" cy="40" rx="16" ry="12" fill="rgba(0,0,0,0.82)"/>
        <ellipse cx="35" cy="40" rx="10" ry="7" fill="rgba(255,255,255,0.12)"/>
        <circle cx="18" cy="30" r="6" fill="rgba(0,0,0,0.82)"/>
        <circle cx="52" cy="30" r="6" fill="rgba(0,0,0,0.82)"/>
        <!-- hi-hat / cymbal hints -->
        <ellipse cx="22" cy="18" rx="6" ry="2.5" fill="rgba(0,0,0,0.82)"/>
        <ellipse cx="48" cy="18" rx="6" ry="2.5" fill="rgba(0,0,0,0.82)"/>
      </g>
    </svg>`;
  }
  function paSvg() {
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="26" y="16" width="18" height="38" rx="6" fill="rgba(0,0,0,0.82)"/>
      <circle cx="35" cy="28" r="5" fill="rgba(255,255,255,0.22)"/>
      <circle cx="35" cy="44" r="7" fill="rgba(255,255,255,0.22)"/>
    </svg>`;
  }
  function micSvg() {
    // generic mic (legacy)
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <circle cx="35" cy="24" r="10" fill="rgba(0,0,0,0.82)"/>
      <rect x="31" y="34" width="8" height="16" rx="4" fill="rgba(0,0,0,0.82)"/>
      <rect x="28" y="50" width="14" height="4" rx="2" fill="rgba(0,0,0,0.82)"/>
    </svg>`;
  }

  function sm58Svg(){
    // SM58-like top-down simplified icon (grille + handle)
    const dots = Array.from({length: 24}).map((_,i)=>{
      const angle = (Math.PI*2/24) * i;
      const r = 6;
      const cx = 35 + Math.cos(angle) * r * 0.6;
      const cy = 18 + Math.sin(angle) * r * 0.6;
      return `<circle cx="${cx.toFixed(1)}" cy="${cy.toFixed(1)}" r="0.9" fill="rgba(255,255,255,0.85)" opacity="0.9"/>`;
    }).join('');
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <ellipse cx="35" cy="18" rx="10" ry="8" fill="rgba(0,0,0,0.92)"/>
        <g opacity="0.6">${dots}</g>
        <rect x="32" y="26" width="6" height="20" rx="3" fill="rgba(0,0,0,0.92)"/>
        <rect x="28" y="46" width="14" height="6" rx="2" fill="rgba(0,0,0,0.92)"/>
      </g>
    </svg>`;
  }

  // Gear set
  function playbackRigSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="14" y="14" width="42" height="42" rx="8" fill="rgba(0,0,0,0.82)"/>
      <rect x="20" y="22" width="30" height="6" rx="3" fill="rgba(255,255,255,0.22)"/>
      <rect x="20" y="32" width="30" height="6" rx="3" fill="rgba(255,255,255,0.22)"/>
      <rect x="20" y="42" width="30" height="6" rx="3" fill="rgba(255,255,255,0.22)"/>
      <text x="35" y="66" text-anchor="middle" font-size="10" fill="rgba(0,0,0,0.60)">PB</text>
    </svg>`;
  }
  function cdj2000Svg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="10" y="10" width="50" height="50" rx="6" fill="rgba(0,0,0,0.86)"/>
      <circle cx="35" cy="35" r="14" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
      <circle cx="35" cy="35" r="3" fill="rgba(255,255,255,0.55)"/>
      <rect x="16" y="16" width="12" height="6" rx="2" fill="rgba(255,255,255,0.18)"/>
      <rect x="42" y="16" width="12" height="6" rx="2" fill="rgba(255,255,255,0.18)"/>
      <rect x="16" y="50" width="38" height="6" rx="2" fill="rgba(255,255,255,0.18)"/>
    </svg>`;
  }
  function cdj3000Svg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="8" y="8" width="54" height="54" rx="8" fill="rgba(0,0,0,0.86)"/>
      <circle cx="35" cy="35" r="16" fill="rgba(255,255,255,0.08)" stroke="rgba(255,255,255,0.35)" stroke-width="2"/>
      <circle cx="35" cy="35" r="3" fill="rgba(255,255,255,0.55)"/>
      <rect x="14" y="14" width="18" height="8" rx="2" fill="rgba(255,255,255,0.18)"/>
      <rect x="38" y="14" width="18" height="8" rx="2" fill="rgba(255,255,255,0.18)"/>
      <rect x="14" y="50" width="42" height="8" rx="2" fill="rgba(255,255,255,0.18)"/>
    </svg>`;
  }
  function djmA9Svg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="8" y="16" width="54" height="38" rx="6" fill="rgba(0,0,0,0.86)"/>
      <rect x="12" y="20" width="46" height="10" rx="3" fill="rgba(255,255,255,0.16)"/>
      <rect x="12" y="34" width="46" height="16" rx="3" fill="rgba(255,255,255,0.10)"/>
      <circle cx="18" cy="42" r="2" fill="rgba(255,255,255,0.65)"/>
      <circle cx="28" cy="42" r="2" fill="rgba(255,255,255,0.65)"/>
      <circle cx="38" cy="42" r="2" fill="rgba(255,255,255,0.65)"/>
      <circle cx="48" cy="42" r="2" fill="rgba(255,255,255,0.65)"/>
      <text x="35" y="66" text-anchor="middle" font-size="9" fill="rgba(0,0,0,0.60)">DJM A9</text>
    </svg>`;
  }
  function djm900Svg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="8" y="16" width="54" height="38" rx="6" fill="rgba(0,0,0,0.86)"/>
      <rect x="12" y="20" width="46" height="8" rx="3" fill="rgba(255,255,255,0.16)"/>
      <rect x="12" y="32" width="46" height="18" rx="3" fill="rgba(255,255,255,0.10)"/>
      <rect x="16" y="34" width="6" height="14" rx="2" fill="rgba(255,255,255,0.22)"/>
      <rect x="26" y="34" width="6" height="14" rx="2" fill="rgba(255,255,255,0.22)"/>
      <rect x="36" y="34" width="6" height="14" rx="2" fill="rgba(255,255,255,0.22)"/>
      <rect x="46" y="34" width="6" height="14" rx="2" fill="rgba(255,255,255,0.22)"/>
      <text x="35" y="66" text-anchor="middle" font-size="9" fill="rgba(0,0,0,0.60)">DJM 900</text>
    </svg>`;
  }
  function networkSwitchSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="10" y="24" width="50" height="22" rx="6" fill="rgba(0,0,0,0.82)"/>
      <rect x="14" y="30" width="42" height="4" rx="2" fill="rgba(255,255,255,0.18)"/>
      <g fill="rgba(255,255,255,0.75)">
        <rect x="16" y="36" width="4" height="6" rx="1"/>
        <rect x="22" y="36" width="4" height="6" rx="1"/>
        <rect x="28" y="36" width="4" height="6" rx="1"/>
        <rect x="34" y="36" width="4" height="6" rx="1"/>
        <rect x="40" y="36" width="4" height="6" rx="1"/>
        <rect x="46" y="36" width="4" height="6" rx="1"/>
        <rect x="52" y="36" width="4" height="6" rx="1"/>
      </g>
      <text x="35" y="66" text-anchor="middle" font-size="9" fill="rgba(0,0,0,0.60)">Switch</text>
    </svg>`;
  }
  function laptopSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="18" y="18" width="34" height="24" rx="4" fill="rgba(0,0,0,0.82)"/>
      <rect x="21" y="21" width="28" height="18" rx="3" fill="rgba(255,255,255,0.18)"/>
      <path d="M14 46 H56 L52 54 H18 Z" fill="rgba(0,0,0,0.82)"/>
    </svg>`;
  }
  function chairSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="24" y="18" width="22" height="18" rx="4" fill="rgba(0,0,0,0.82)"/>
      <rect x="22" y="34" width="26" height="10" rx="4" fill="rgba(0,0,0,0.82)"/>
      <rect x="22" y="44" width="4" height="14" fill="rgba(0,0,0,0.82)"/>
      <rect x="44" y="44" width="4" height="14" fill="rgba(0,0,0,0.82)"/>
    </svg>`;
  }
  function power120Svg(){ return baseBox("120V"); }
  function powerDropSvg(){ return baseBox("PWR"); }

  function standStraightSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <line x1="35" y1="12" x2="35" y2="44" stroke="rgba(0,0,0,0.92)" stroke-width="4" stroke-linecap="round"/>
        <!-- tripod legs simplified -->
        <line x1="35" y1="44" x2="14" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="35" y1="44" x2="56" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <circle cx="35" cy="10" r="4" fill="rgba(0,0,0,0.92)"/>
      </g>
    </svg>`;
  }
  function standStraightRoundSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <line x1="35" y1="12" x2="35" y2="46" stroke="rgba(0,0,0,0.92)" stroke-width="4" stroke-linecap="round"/>
        <circle cx="35" cy="10" r="4" fill="rgba(0,0,0,0.92)"/>
        <circle cx="35" cy="56" r="10" fill="rgba(0,0,0,0.92)"/>
        <circle cx="35" cy="56" r="6" fill="rgba(255,255,255,0.08)"/>
      </g>
    </svg>`;
  }
  function standBoomSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <line x1="34" y1="14" x2="34" y2="48" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="34" y1="48" x2="12" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="34" y1="48" x2="56" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="36" y1="22" x2="56" y2="16" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <circle cx="56" cy="16" r="3" fill="rgba(0,0,0,0.92)"/>
      </g>
    </svg>`;
  }
  function standBoomRoundSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <line x1="35" y1="14" x2="35" y2="46" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="37" y1="22" x2="58" y2="16" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <circle cx="58" cy="16" r="3" fill="rgba(0,0,0,0.92)"/>
        <circle cx="35" cy="56" r="10" fill="rgba(0,0,0,0.92)"/>
        <circle cx="35" cy="56" r="6" fill="rgba(255,255,255,0.08)"/>
      </g>
    </svg>`;
  }
  function standShortBoomSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g>
        <line x1="34" y1="26" x2="34" y2="50" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="34" y1="50" x2="14" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="34" y1="50" x2="54" y2="64" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <line x1="36" y1="30" x2="54" y2="26" stroke="rgba(0,0,0,0.92)" stroke-width="3" stroke-linecap="round"/>
        <circle cx="54" cy="26" r="3" fill="rgba(0,0,0,0.92)"/>
      </g>
    </svg>`;
  }

  function wirelessPackSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="24" y="14" width="22" height="36" rx="5" fill="rgba(0,0,0,0.82)"/>
      <rect x="27" y="18" width="16" height="10" rx="2" fill="rgba(255,255,255,0.18)"/>
      <circle cx="30" cy="34" r="1.5" fill="rgba(255,255,255,0.45)"/>
      <circle cx="35" cy="34" r="1.5" fill="rgba(255,255,255,0.45)"/>
      <circle cx="40" cy="34" r="1.5" fill="rgba(255,255,255,0.45)"/>
      <rect x="22" y="24" width="4" height="18" rx="2" fill="rgba(0,0,0,0.65)"/>
      <path d="M46 16 L54 10" stroke="rgba(0,0,0,0.82)" stroke-width="3" stroke-linecap="round"/>
      <circle cx="54" cy="10" r="2.2" fill="rgba(0,0,0,0.82)"/>
      <text x="35" y="62" text-anchor="middle" font-size="10" fill="rgba(0,0,0,0.60)">PACK</text>
    </svg>`;
  }

  function earsRackSvg(){ return baseBox("IEM"); }
  function diMonoSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="20" width="46" height="30" rx="6" fill="rgba(0,0,0,0.82)"/>
      <rect x="18" y="28" width="34" height="12" rx="3" fill="rgba(255,255,255,0.12)"/>
      <text x="35" y="50" text-anchor="middle" font-size="12" fill="rgba(255,255,255,0.85)">DI</text>
    </svg>`;
  }
  function diStereoSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="20" width="46" height="30" rx="6" fill="rgba(0,0,0,0.82)"/>
      <rect x="14" y="26" width="22" height="12" rx="3" fill="rgba(255,255,255,0.12)"/>
      <rect x="34" y="26" width="22" height="12" rx="3" fill="rgba(255,255,255,0.12)"/>
      <text x="35" y="50" text-anchor="middle" font-size="10" fill="rgba(255,255,255,0.85)">2DI</text>
    </svg>`;
  }

  function riserSvg(){
    // simplified rectangular riser that scales uniformly with svgBW/svgBH metadata
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="5" y="17.5" width="60" height="35" rx="4"
        fill="rgba(0,0,0,0.08)" stroke="rgba(0,0,0,0.75)" stroke-width="2"/>
      <rect x="12" y="52" width="6" height="8" rx="2" fill="rgba(0,0,0,0.55)"/>
      <rect x="30" y="52" width="6" height="8" rx="2" fill="rgba(0,0,0,0.55)"/>
      <rect x="48" y="52" width="6" height="8" rx="2" fill="rgba(0,0,0,0.55)"/>
      <text x="35" y="39" text-anchor="middle" font-size="11" fill="rgba(0,0,0,0.75)">RISER</text>
    </svg>`;
  }

  function stoolSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <ellipse cx="35" cy="20" rx="14" ry="8" fill="rgba(0,0,0,0.82)"/>
      <path d="M27 26 L22 62" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <path d="M43 26 L48 62" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <path d="M35 26 L35 66" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <ellipse cx="35" cy="46" rx="14" ry="6" fill="none" stroke="rgba(255,255,255,0.16)" stroke-width="3"/>
    </svg>`;
  }
  function kbdStandSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="18" y="16" width="34" height="8" rx="4" fill="rgba(0,0,0,0.82)"/>
      <path d="M22 24 L48 56" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <path d="M48 24 L22 56" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
    </svg>`;
  }
  function gtrStandSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <path d="M35 18 C30 18 27 22 27 26 C27 30 30 34 35 34 C40 34 43 30 43 26 C43 22 40 18 35 18 Z" fill="rgba(0,0,0,0.82)"/>
      <path d="M35 34 L35 48" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <path d="M35 48 L22 60" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
      <path d="M35 48 L48 60" stroke="rgba(0,0,0,0.82)" stroke-width="4" stroke-linecap="round"/>
    </svg>`;
  }
  function stageBoxSvg(){ return baseBox("SB"); }
  function rugSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="14" width="46" height="40" rx="8" fill="rgba(0,0,0,0.06)" stroke="rgba(0,0,0,0.55)" stroke-width="2"/>
      <!-- subtle frayed edges -->
      <path d="M14 16 L16 18 M56 16 L54 18 M14 50 L16 48 M56 50 L54 48" stroke="rgba(0,0,0,0.30)" stroke-width="1" stroke-linecap="round"/>
      <text x="35" y="38" text-anchor="middle" font-size="10" fill="rgba(0,0,0,0.7)">RUG</text>
    </svg>`;
  }
  function rfAntennaSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="28" y="42" width="14" height="10" rx="3" fill="rgba(0,0,0,0.82)"/>
      <rect x="33" y="18" width="4" height="24" rx="2" fill="rgba(0,0,0,0.82)"/>
      <path d="M35 16 C44 18 48 26 48 35" fill="none" stroke="rgba(0,0,0,0.55)" stroke-width="2"/>
      <path d="M35 12 C48 15 56 26 56 40" fill="none" stroke="rgba(0,0,0,0.30)" stroke-width="2"/>
    </svg>`;
  }

  // Instruments / people (improved silhouettes)
  function bandMemberSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g fill="rgba(0,0,0,0.82)">
        <circle cx="35" cy="14" r="8"/>
        <rect x="22" y="24" width="26" height="26" rx="10"/>
        <rect x="20.5" y="30" width="6" height="22" rx="3"/>
        <rect x="43.5" y="30" width="6" height="22" rx="3"/>
        <path d="M28 50 L42 50 L45 66 L25 66 Z"/>
      </g>
    </svg>`;
  }

  function singerSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <g fill="rgba(0,0,0,0.82)">
        <circle cx="35" cy="14" r="8"/>
        <rect x="22" y="24" width="26" height="26" rx="10"/>
        <rect x="20.5" y="30" width="6" height="22" rx="3"/>
        <rect x="43.5" y="30" width="6" height="22" rx="3"/>
        <path d="M28 50 L42 50 L45 66 L25 66 Z"/>
      </g>
      <ellipse cx="35" cy="17.5" rx="2.2" ry="3.0" fill="rgba(255,255,255,0.95)"/>
    </svg>`;
  }

  function acousticGtrSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <!-- acoustic guitar (improved) -->
      <path d="M35 22 C28 22 24 27 24 33 C24 38 28 41 32 42 C30 44 27 48 27 52 C27 57 31 61 35 61 C39 61 43 57 43 52 C43 48 40 44 38 42 C42 41 46 38 46 33 C46 27 42 22 35 22 Z" fill="rgba(0,0,0,0.92)"/>
      <rect x="32" y="6" width="6" height="20" rx="2" fill="rgba(0,0,0,0.92)"/>
      <circle cx="35" cy="37" r="5" fill="rgba(255,255,255,0.12)"/>
      <line x1="35" y1="20" x2="35" y2="60" stroke="rgba(255,255,255,0.06)" stroke-width="1"/>
    </svg>`;
  }

  function electricGtrSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <!-- electric guitar (improved) -->
      <path d="M22 40 C22 40 26 34 34 32 C38 31 44 28 50 30 C56 32 58 36 56 40 C54 44 48 48 42 50 C36 52 30 50 26 46 C24 44 22 40 22 40 Z" fill="rgba(0,0,0,0.92)"/>
      <rect x="30" y="6" width="6" height="28" rx="2" fill="rgba(0,0,0,0.92)"/>
      <rect x="30" y="4" width="14" height="6" rx="2" fill="rgba(0,0,0,0.92)"/>
      <rect x="34" y="36" width="8" height="6" rx="1.5" fill="rgba(255,255,255,0.08)"/>
    </svg>`;
  }

  function bassGtrSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <!-- bass guitar (long neck) -->
      <path d="M24 40 C24 40 28 34 36 32 C40 31 46 30 52 32 C56 33 58 36 57 40 C56 44 52 48 46 50 C40 52 34 51 30 48 C28 46 24 40 24 40 Z" fill="rgba(0,0,0,0.92)"/>
      <rect x="26" y="2" width="5" height="36" rx="2" fill="rgba(0,0,0,0.92)"/>
      <g fill="rgba(255,255,255,0.12)">
        <circle cx="30" cy="6" r="1.2"/>
        <circle cx="30" cy="10" r="1.2"/>
        <circle cx="30" cy="14" r="1.2"/>
      </g>
    </svg>`;
  }

  function violinSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <!-- violin -->
      <path d="M35 20 C30 20 27 24 27 28 C27 31 29 33 31 34 C29 36 27 38 27 41 C27 45 30 48 35 48 C40 48 43 45 43 41 C43 38 41 36 39 34 C41 33 43 31 43 28 C43 24 40 20 35 20 Z" fill="rgba(0,0,0,0.92)"/>
      <rect x="33" y="8" width="4" height="14" rx="2" fill="rgba(0,0,0,0.92)"/>
      <path d="M31 6 H39 C41 6 42 7.5 42 9.5 V12.5 C42 14.5 41 15.5 39 15.5 H31 Z" fill="rgba(0,0,0,0.92)"/>
      <line x1="35" y1="30" x2="35" y2="46" stroke="rgba(255,255,255,0.06)" stroke-width="1"/>
    </svg>`;
  }

  // Misc stage objects
  function lampShadeSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <path d="M22 22 H48 L44 36 H26 Z" fill="rgba(0,0,0,0.18)" stroke="rgba(0,0,0,0.75)" stroke-width="2"/>
    <rect x="33" y="36" width="4" height="16" rx="2" fill="rgba(0,0,0,0.82)"/>
    <rect x="28" y="52" width="14" height="4" rx="2" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function ledWallSvg(){
    const dots = Array.from({length: 20}).map((_,i)=> {
      const x = 14 + (i%5)*10;
      const y = 20 + Math.floor(i/5)*7;
      return `<rect x="${x}" y="${y}" width="6" height="4" rx="0"/>`;
    }).join("");
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="10" y="16" width="50" height="34" rx="0" fill="rgba(0,0,0,0.82)"/>
      <g fill="rgba(255,255,255,0.12)">${dots}</g>
    </svg>`;
  }

  function tvSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="12" y="16" width="46" height="30" rx="6" fill="rgba(0,0,0,0.82)"/>
    <rect x="16" y="20" width="38" height="22" rx="4" fill="rgba(255,255,255,0.16)"/>
    <rect x="30" y="46" width="10" height="6" rx="2" fill="rgba(0,0,0,0.82)"/>
    <rect x="24" y="52" width="22" height="4" rx="2" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function speakerTopSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="22" y="12" width="26" height="46" rx="6" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="26" r="6" fill="rgba(255,255,255,0.18)"/>
    <circle cx="35" cy="44" r="9" fill="rgba(255,255,255,0.18)"/>
  </svg>`; }

  function subSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="18" width="38" height="38" rx="6" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="37" r="12" fill="rgba(255,255,255,0.16)"/>
    <circle cx="35" cy="37" r="7" fill="rgba(255,255,255,0.12)"/>
  </svg>`; }

  function tableSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="14" y="18" width="42" height="18" rx="6" fill="rgba(0,0,0,0.18)" stroke="rgba(0,0,0,0.75)" stroke-width="2"/>
    <rect x="18" y="36" width="6" height="18" rx="2" fill="rgba(0,0,0,0.82)"/>
    <rect x="46" y="36" width="6" height="18" rx="2" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function sideTableSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="22" y="20" width="26" height="14" rx="6" fill="rgba(0,0,0,0.18)" stroke="rgba(0,0,0,0.75)" stroke-width="2"/>
    <rect x="26" y="34" width="6" height="18" rx="2" fill="rgba(0,0,0,0.82)"/>
    <rect x="38" y="34" width="6" height="18" rx="2" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function albatrosIemAmpSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="18" width="38" height="34" rx="7" fill="rgba(0,0,0,0.82)"/>
    <circle cx="44" cy="35" r="6" fill="rgba(255,255,255,0.18)"/>
    <rect x="20" y="24" width="16" height="6" rx="3" fill="rgba(255,255,255,0.18)"/>
    <text x="35" y="64" text-anchor="middle" font-size="10" fill="rgba(0,0,0,0.60)">IEM AMP</text>
  </svg>`; }

  function grandPianoSvg(){
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <!-- refined top-down grand piano silhouette -->
      <path d="M16 52 C11 40 14 20 33 12 C50 6 64 18 64 34 C64 52 48 64 33 62 C24 61 19 58 16 52 Z" fill="rgba(0,0,0,0.92)"/>
      <!-- keyboard area with clearer keys -->
      <rect x="18" y="40" width="36" height="12" rx="2" fill="rgba(255,255,255,0.14)"/>
      <g fill="rgba(0,0,0,0.85)">
        <rect x="20" y="41" width="3" height="10" rx="1"/>
        <rect x="24.5" y="41" width="3" height="10" rx="1"/>
        <rect x="29" y="41" width="3" height="10" rx="1"/>
        <rect x="33.5" y="41" width="3" height="10" rx="1"/>
        <rect x="38" y="41" width="3" height="10" rx="1"/>
        <rect x="42.5" y="41" width="3" height="10" rx="1"/>
      </g>
      <text x="33" y="58" text-anchor="middle" font-size="9" fill="rgba(255,255,255,0.18)">Piano</text>
    </svg>`;
  }

  function keyboardSvg(){
    // Nord-ish top-down keyboard
    const keys = Array.from({length: 10}).map((_,i)=>`<rect x="${16+i*3.6}" y="31" width="2.4" height="14" rx="1"/>`).join("");
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="10" y="22" width="50" height="26" rx="6" fill="rgba(0,0,0,0.82)"/>
      <rect x="14" y="28" width="42" height="18" rx="4" fill="rgba(255,255,255,0.14)"/>
      <g fill="rgba(0,0,0,0.85)">${keys}</g>
      <rect x="52" y="32" width="6" height="6" rx="1" fill="rgba(255,255,255,0.20)"/>
    </svg>`;
  }

  function drumPadSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="14" y="16" width="42" height="38" rx="8" fill="rgba(0,0,0,0.82)"/>
    <g fill="rgba(255,255,255,0.14)">
      <rect x="20" y="22" width="12" height="10" rx="3"/>
      <rect x="38" y="22" width="12" height="10" rx="3"/>
      <rect x="20" y="36" width="12" height="10" rx="3"/>
      <rect x="38" y="36" width="12" height="10" rx="3"/>
    </g>
  </svg>`; }

  function guitarBoatSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="10" y="20" width="50" height="26" rx="8" fill="rgba(0,0,0,0.18)" stroke="rgba(0,0,0,0.75)" stroke-width="2"/>
    <g stroke="rgba(0,0,0,0.75)" stroke-width="2" stroke-linecap="round">
      <path d="M18 24 V42"/>
      <path d="M26 24 V42"/>
      <path d="M34 24 V42"/>
      <path d="M42 24 V42"/>
      <path d="M50 24 V42"/>
    </g>
    <text x="35" y="62" text-anchor="middle" font-size="10" fill="rgba(0,0,0,0.60)">GTR BOAT</text>
  </svg>`; }

  // Lighting fixtures (generic)
  function parCanSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <circle cx="35" cy="32" r="14" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="32" r="8" fill="rgba(255,255,255,0.16)"/>
    <rect x="28" y="48" width="14" height="6" rx="3" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function fresnelSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="20" y="18" width="30" height="28" rx="8" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="32" r="7" fill="rgba(255,255,255,0.16)"/>
    <rect x="28" y="46" width="14" height="8" rx="4" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function lekoSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="22" width="26" height="20" rx="6" fill="rgba(0,0,0,0.82)"/>
    <path d="M42 24 L58 32 L42 40 Z" fill="rgba(0,0,0,0.82)"/>
    <circle cx="26" cy="32" r="6" fill="rgba(255,255,255,0.16)"/>
  </svg>`; }

  function movingHeadSpotSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="22" y="42" width="26" height="12" rx="4" fill="rgba(0,0,0,0.82)"/>
    <rect x="26" y="22" width="18" height="22" rx="6" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="33" r="6" fill="rgba(255,255,255,0.16)"/>
  </svg>`; }

  function movingHeadWashSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="22" y="42" width="26" height="12" rx="4" fill="rgba(0,0,0,0.82)"/>
    <rect x="24" y="22" width="22" height="22" rx="7" fill="rgba(0,0,0,0.82)"/>
    <circle cx="35" cy="33" r="8" fill="rgba(255,255,255,0.14)"/>
  </svg>`; }

  function ledBarSvg(){
    const dots = Array.from({length: 8}).map((_,i)=>`<circle cx="${18+i*5}" cy="35" r="1.5"/>`).join("");
    return `<svg width="64" height="64" viewBox="0 0 70 70">
      <rect x="12" y="30" width="46" height="10" rx="5" fill="rgba(0,0,0,0.82)"/>
      <g fill="rgba(255,255,255,0.18)">${dots}</g>
    </svg>`;
  }

  function strobeSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="14" y="24" width="42" height="22" rx="6" fill="rgba(0,0,0,0.82)"/>
    <rect x="18" y="28" width="34" height="14" rx="4" fill="rgba(255,255,255,0.18)"/>
    <path d="M58 24 L64 18" stroke="rgba(0,0,0,0.6)" stroke-width="2"/>
  </svg>`; }

  function blinder2Svg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="26" width="38" height="18" rx="6" fill="rgba(0,0,0,0.82)"/>
    <circle cx="28" cy="35" r="6" fill="rgba(255,255,255,0.16)"/>
    <circle cx="42" cy="35" r="6" fill="rgba(255,255,255,0.16)"/>
  </svg>`; }

  function blinder4Svg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="14" y="22" width="42" height="26" rx="6" fill="rgba(0,0,0,0.82)"/>
    <circle cx="26" cy="31" r="5" fill="rgba(255,255,255,0.16)"/>
    <circle cx="44" cy="31" r="5" fill="rgba(255,255,255,0.16)"/>
    <circle cx="26" cy="39" r="5" fill="rgba(255,255,255,0.16)"/>
    <circle cx="44" cy="39" r="5" fill="rgba(255,255,255,0.16)"/>
  </svg>`; }

  function followspotSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="32" width="22" height="12" rx="6" fill="rgba(0,0,0,0.82)"/>
    <path d="M38 32 L60 26 L60 50 L38 44 Z" fill="rgba(0,0,0,0.82)"/>
    <rect x="22" y="44" width="10" height="10" rx="3" fill="rgba(0,0,0,0.82)"/>
  </svg>`; }

  function hazerSvg(){ return `<svg width="64" height="64" viewBox="0 0 70 70">
    <rect x="16" y="34" width="34" height="18" rx="6" fill="rgba(0,0,0,0.82)"/>
    <path d="M50 38 C58 38 62 44 62 52" fill="none" stroke="rgba(0,0,0,0.45)" stroke-width="3"/>
    <path d="M50 34 C60 34 66 42 66 54" fill="none" stroke="rgba(0,0,0,0.25)" stroke-width="3"/>
  </svg>`; }

  // ============================================================
  // LIBRARY ITEMS
  // ============================================================
  const LIB_ITEMS = [
    // Quick-create tools
    { type:"text", id:"text_box", name:"Text Box", svg: textThumbSvg() },
    { type:"shape", id:"shape_square", name:"Square", svg: squareThumbSvg(), shape:"rect", defW: 200, defH: 200, defWUnits: 4, defHUnits: 4 },
    { type:"shape", id:"shape_circle", name:"Circle", svg: circleThumbSvg(), shape:"circle", defW: 200, defH: 200, defWUnits: 4, defHUnits: 4 },

    // Playback / utilities
    { type:"icon", id:"playback_rig", name:"Playback Rig", svg: playbackRigSvg() },
    { type:"icon", id:"cdj_2000", name:"CDJ 2000", svg: cdj2000Svg() },
    { type:"icon", id:"cdj_3000", name:"CDJ 3000", svg: cdj3000Svg() },
    { type:"icon", id:"djm_a9", name:"DJM A9 Mixer", svg: djmA9Svg() },
    { type:"icon", id:"djm_900", name:"DJM 900 Mixer", svg: djm900Svg() },
    { type:"icon", id:"network_switch", name:"Network Switch", svg: networkSwitchSvg() },
    { type:"icon", id:"laptop", name:"Laptop", svg: laptopSvg() },
    { type:"icon", id:"chair", name:"Chair", svg: chairSvg(), defWUnits: 1.5, defHUnits: 1.5 },
    { type:"icon", id:"power_120v", name:"120V", svg: power120Svg(), defVoltage: "120V", bw: 100, bh: 42 },
    { type:"icon", id:"power_drop", name:"Power Drop", svg: powerDropSvg() },

    // Stands / RF / IEM
    { type:"icon", id:"stand_straight", name:"Stand (Straight)", svg: standStraightSvg() },
    { type:"icon", id:"stand_boom", name:"Stand (Boom)", svg: standBoomSvg() },
    { type:"icon", id:"stand_straight_round", name:"Stand (Straight, Round Base)", svg: standStraightRoundSvg() },
    { type:"icon", id:"stand_boom_round", name:"Stand (Boom, Round Base)", svg: standBoomRoundSvg() },
    { type:"icon", id:"stand_short_boom", name:"Stand (Short Boom)", svg: standShortBoomSvg() },
    { type:"icon", id:"wireless_pack", name:"Wireless Pack", svg: wirelessPackSvg() },
    { type:"icon", id:"ears_rack", name:"Wireless Ears Rack", svg: earsRackSvg() },
    { type:"icon", id:"rf_antenna", name:"RF Antenna", svg: rfAntennaSvg() },
    { type:"icon", id:"albatros_iem", name:"Albatros IEM Amp", svg: albatrosIemAmpSvg() },

    // DIs / boxes
    { type:"icon", id:"di_mono", name:"DI (Mono)", svg: diMonoSvg() },
    { type:"icon", id:"di_stereo", name:"DI (Stereo)", svg: diStereoSvg() },
    { type:"icon", id:"stage_box", name:"Stage Box", svg: stageBoxSvg() },

    // Stage furniture / platforms
    { type:"icon", id:"riser", name:"Riser", svg: riserSvg(), defWUnits: 8, defHUnits: 4, svgBW:60, svgBH:35 },
    { type:"icon", id:"rug", name:"Rug", svg: rugSvg() },
    { type:"icon", id:"table", name:"Table", svg: tableSvg(), defWUnits: 6.5, defHUnits: 2.75, svgBW:42, svgBH:18 },
    { type:"icon", id:"side_table", name:"Side Table", svg: sideTableSvg(), defS: 1.8 },
    { type:"icon", id:"lamp_shade", name:"Lamp (Shade)", svg: lampShadeSvg() },

    // Video / walls
    { type:"icon", id:"led_wall", name:"LED Wall", svg: ledWallSvg(), defS: 3.2 },
    { type:"icon", id:"tv", name:"TV", svg: tvSvg(), defS: 2.2 },

    // Audio PA
    { type:"icon", id:"speaker_top", name:"Speaker (Top)", svg: speakerTopSvg() },
    { type:"icon", id:"sub", name:"Sub", svg: subSvg() },

    // Instruments / people
    { type:"icon", id:"acoustic_guitar", name:"Acoustic Guitar", svg: acousticGtrSvg(), defWUnits: 1.4, defHUnits: 3.6 },
    { type:"icon", id:"electric_guitar", name:"Electric Guitar", svg: electricGtrSvg(), defWUnits: 1.3, defHUnits: 3.4 },
    { type:"icon", id:"bass", name:"Bass Guitar", svg: bassGtrSvg(), defWUnits: 1.4, defHUnits: 4.0 },
    { type:"icon", id:"violin", name:"Violin", svg: violinSvg(), defWUnits: 0.7, defHUnits: 2.0 },
    { type:"icon", id:"guitar_boat", name:"Guitar Boat", svg: guitarBoatSvg(), defWUnits: 5.0, defHUnits: 2.5 },
    { type:"icon", id:"gtr_stand", name:"Guitar Stand", svg: gtrStandSvg() },
    { type:"icon", id:"kbd_stool", name:"Keyboard Stool", svg: stoolSvg() },
    { type:"icon", id:"kbd_stand", name:"Keyboard Stand", svg: kbdStandSvg() },
    { type:"icon", id:"keyboard", name:"Keyboard", svg: keyboardSvg(), defWUnits: 4.5, defHUnits: 1.5 },
    { type:"icon", id:"grand_piano", name:"Grand Piano", svg: grandPianoSvg(), defWUnits: 6.5, defHUnits: 9.0 },
    { type:"icon", id:"drum_pad", name:"Drum Pad", svg: drumPadSvg() },
    { type:"icon", id:"band_member", name:"Band Member (Unisex)", svg: bandMemberSvg() },
    { type:"icon", id:"singer", name:"Singer (Unisex)", svg: singerSvg() },

    // Lighting fixtures
    { type:"icon", id:"par_can", name:"Light: PAR Can", svg: parCanSvg() },
    { type:"icon", id:"fresnel", name:"Light: Fresnel", svg: fresnelSvg() },
    { type:"icon", id:"leko", name:"Light: Ellipsoidal (Leko)", svg: lekoSvg() },
    { type:"icon", id:"moving_spot", name:"Light: Moving Head Spot", svg: movingHeadSpotSvg() },
    { type:"icon", id:"moving_wash", name:"Light: Moving Head Wash", svg: movingHeadWashSvg() },
    { type:"icon", id:"led_bar", name:"Light: LED Bar", svg: ledBarSvg() },
    { type:"icon", id:"strobe", name:"Light: Strobe", svg: strobeSvg() },
    { type:"icon", id:"blinder_2", name:"Light: 2-Lite Blinder", svg: blinder2Svg() },
    { type:"icon", id:"blinder_4", name:"Light: 4-Lite Blinder", svg: blinder4Svg() },
    { type:"icon", id:"followspot", name:"Light: Followspot", svg: followspotSvg() },
    { type:"icon", id:"hazer", name:"Atmos: Hazer/Fog", svg: hazerSvg() },

    // Basics
    { type:"icon", id:"wedge", name:"Wedge", svg: wedgeSvg() },
    { type:"icon", id:"amp", name:"Amp", svg: ampSvg() },
    { type:"icon", id:"drum", name:"Drum Kit", svg: drumSvg(), defWUnits: 6.5, defHUnits: 5.5 },
    { type:"icon", id:"pa", name:"PA", svg: paSvg() },
    { type:"icon", id:"mic", name:"Mic", svg: micSvg(), defWUnits: 0.25, defHUnits: 0.7 },
    { type:"icon", id:"sm58", name:"SM58", svg: sm58Svg() },
  ].map((x) => {
    if (x.type === "icon") {
      return { ...x, svgGroup: makeTintableSvgGroup(x.svg) };
    }
    return x;
  });

  const EXTERNAL_ICON_SOURCES = {
    acoustic_guitar: "icons/acousticguitar.svg",
    electric_guitar: "icons/electricguitar.svg",
    bass: "icons/bassguitar.svg",
    grand_piano: "icons/grandpiano.svg",
    keyboard: "icons/keyboard.svg",
    violin: "icons/violin.svg",
    mic: "icons/microphone.svg",
  };

  function findLibById(id){ return LIB_ITEMS.find(x => x.id === id) || null; }

  async function loadExternalIconSvgs() {
    const entries = Object.entries(EXTERNAL_ICON_SOURCES);
    await Promise.all(entries.map(async ([id, url]) => {
      try {
        const res = await fetch(url, { cache: "no-cache" });
        if (!res.ok) return;
        const text = await res.text();
        const built = buildExternalIconSvg(text);
        if (!built) return;
        const lib = findLibById(id);
        if (!lib) return;
        lib.svg = built.thumbSvg;
        lib.svgGroup = built.svgGroup;
      } catch (err) {
        // ignore and keep fallback inline icon
      }
    }));
  }

  // ============================================================
  // STATE
  // ============================================================
  let stage = { w: 1200, h: 700, showGrid: true, zoom: 1 };

  // items: back-to-front ordering (later = front)
  // kinds: icon, text, image, shape, cable
  let items = [];

  // groups: gid => {name}
  let groups = {};
  let groupCounter = 1;

  // selection
  let selected = new Set(); // ids
  let primaryId = null;
  let dragSelect = { active: false, start: null, end: null };

  // drag
  let drag = {
    active: false,
    mode: null,      // "move" | "vertex"
    pointerId: null,
    start: null,     // {x,y}
    ids: [],
    primaryId: null,
    originals: null, // Map(id -> snapshot)
    vertex: null,    // {id, index}
  };

  // cable tool
  let cableTool = { on: false, draft: null };

  // UI state
  let ui = { groupCollapsed: {} };

  // history
  let history = { stack: [], index: -1, suspend: false, debounceTimer: null };

  // ============================================================
  // LIBRARY RENDER
  // ============================================================
  function renderLibrary(filter = "") {
    const q = filter.trim().toLowerCase();
    els.libgrid.innerHTML = "";
    LIB_ITEMS
      .filter(i => !q || i.name.toLowerCase().includes(q) || i.id.toLowerCase().includes(q))
      .forEach(lib => {
        const card = document.createElement("div");
        card.className = "sp-card";
        card.innerHTML = `
          <div class="sp-thumb">${lib.svg}</div>
          <div class="sp-name">${escapeHtml(lib.name)}</div>
        `;
        card.setAttribute("draggable", "true");
        card.addEventListener("dragstart", (e) => {
          e.dataTransfer.setData("application/x-stageplot-icon", lib.id);
          e.dataTransfer.effectAllowed = "copy";
        });
        card.addEventListener("click", () => { addFromLibrary(lib); root.focus(); });
        els.libgrid.appendChild(card);
      });
  }

  // ============================================================
  // CREATE ITEMS
  // ============================================================
  function normalizeItem(it) {
    const base = { locked: !!it.locked, groupId: it.groupId || null };

    if (it.kind === "icon") {
      return {
        ...base,
        ...it,
        kind: "icon",
        x: num(it.x, stage.w / 2),
        y: num(it.y, stage.h / 2),
        r: num(it.r, 0),
        s: clampf(num(it.s, 1), 0.2, 8),
        color: it.color || defaultIconColor(it.iconId || it.id || "icon"),
        label: it.label || "",
        labelSize: clampf(num(it.labelSize, 14), 8, 72),
        labelColor: it.labelColor || "#111111",
      };
    }

    if (it.kind === "shape") {
      return {
        ...base,
        ...it,
        kind: "shape",
        shape: it.shape === "circle" ? "circle" : "rect",
        x: num(it.x, stage.w / 2),
        y: num(it.y, stage.h / 2),
        r: num(it.r, 0),
        s: clampf(num(it.s, 1), 0.2, 8),
        w: clampf(num(it.w, 200), 20, 4000),
        h: clampf(num(it.h, 200), 20, 4000),
        stroke: it.stroke || "#111111",
        strokeWidth: clampf(num(it.strokeWidth, 4), 1, 30),
        fill: (it.fill === undefined || it.fill === null) ? "none" : it.fill,
        fillOpacity: clampf(num(it.fillOpacity, 1), 0, 1),
        label: it.label || "",
        labelSize: clampf(num(it.labelSize, 14), 8, 72),
        labelColor: it.labelColor || "#111111",
      };
    }

    if (it.kind === "text") {
      return {
        ...base,
        ...it,
        kind: "text",
        x: num(it.x, stage.w / 2),
        y: num(it.y, stage.h / 2),
        r: num(it.r, 0),
        s: clampf(num(it.s, 1), 0.2, 8),
        text: it.text || "Text",
        fontSize: clampf(num(it.fontSize, 24), 8, 200),
        color: it.color || "#111111",
      };
    }

    if (it.kind === "image") {
      return {
        ...base,
        ...it,
        kind: "image",
        x: num(it.x, stage.w / 2),
        y: num(it.y, stage.h / 2),
        r: num(it.r, 0),
        s: clampf(num(it.s, 1), 0.2, 8),
        href: it.href || "",
        name: it.name || "Image",
        iw: clampf(num(it.iw, 220), 30, 4000),
        ih: clampf(num(it.ih, 220), 30, 4000),
        label: it.label || "",
        labelSize: clampf(num(it.labelSize, 14), 8, 72),
        labelColor: it.labelColor || "#111111",
      };
    }

    if (it.kind === "cable") {
      return {
        ...base,
        ...it,
        kind: "cable",
        points: Array.isArray(it.points) ? it.points.map(p => ({ x: num(p.x, 0), y: num(p.y, 0) })) : [],
        color: it.color || "#111111",
        width: clampf(num(it.width, 3), 1, 20),
      };
    }

    return it;
  }

  function addFromLibrary(lib) {
    if (lib.type === "text") { addTextItem(); return; }
    if (lib.type === "shape") {
      const w = (lib.defWUnits != null) ? unitsToPx(lib.defWUnits) : lib.defW;
      const h = (lib.defHUnits != null) ? unitsToPx(lib.defHUnits) : lib.defH;
      addShapeItem(lib.shape, lib.name, w, h);
      return;
    }
    if (lib.type === "icon") { addIconItem(lib); return; }
  }

  function addIconItem(libIcon) {
    // Use the same logic as drag-drop to preserve special cases (e.g., riser as shape)
    addIconItemAt(libIcon, stage.w / 2, stage.h / 2);
  }

  function addShapeItem(shape, name, w = 200, h = 200) {
    const id = uid();
    const it = normalizeItem({
      id,
      kind: "shape",
      shape: shape === "circle" ? "circle" : "rect",
      name,
      x: stage.w / 2,
      y: stage.h / 2,
      r: 0,
      s: 1,
      w,
      h,
      stroke: "#111111",
      strokeWidth: 4,
      fill: "none",
      fillOpacity: 1,
      locked: false,
      label: "",
      labelSize: 14,
      labelColor: "#111111",
    });
    items.push(it);
    selectOnly([id]);
    pushHistory("add shape");
    draw();
  }

  function addTextItem() {
    const id = uid();
    const it = normalizeItem({
      id,
      kind: "text",
      name: "Text",
      x: stage.w / 2,
      y: stage.h / 2,
      r: 0,
      s: 1,
      text: "Text",
      fontSize: 24,
      color: "#111111",
      locked: false,
    });
    items.push(it);
    selectOnly([id]);
    pushHistory("add text");
    draw();
  }

  function addImageItem(dataUrl, fileName = "Image") {
    const id = uid();
    const it = normalizeItem({
      id,
      kind: "image",
      name: fileName,
      x: stage.w / 2,
      y: stage.h / 2,
      r: 0,
      s: 1,
      href: dataUrl,
      iw: 220,
      ih: 220,
      locked: false,
      label: "",
      labelSize: 14,
      labelColor: "#111111",
    });
    items.push(it);
    selectOnly([id]);
    pushHistory("add image");
    draw();
  }

  function addIconItemAt(icon, x, y) {
    const id = uid();
    // compute scale: if the library item specifies real-world default width/height
    // in stage units (defWUnits/defHUnits), prefer that to a static defS.
    let s = icon.defS ?? 1;
    if (icon.defWUnits) {
      try {
        const svgBW = icon.svgBW || 70;
        s = unitsToPx(icon.defWUnits) / svgBW;
      } catch (err) { s = icon.defS ?? 1; }
    }
    // Special-case: riser should be a true shape so it can be sized exactly
    if (icon.id === 'riser' || icon.id === 'table') {
      const wPx = icon.defWUnits ? unitsToPx(icon.defWUnits) : unitsToPx(8);
      const hPx = icon.defHUnits ? unitsToPx(icon.defHUnits) : unitsToPx(4);
      items.push(normalizeItem({
        id,
        kind: "shape",
        shape: "rect",
        name: icon.name,
        x: clampf(x, 0, stage.w), y: clampf(y, 0, stage.h),
        r: 0,
        s: 1,
        w: clampf(wPx, 20, 4000),
        h: clampf(hPx, 20, 4000),
        fill: "rgba(0,0,0,0.08)",
        stroke: "#111111",
        strokeWidth: 2,
        label: icon.name,
        labelSize: 11,
        labelColor: "#111111",
        locked: false,
        isRiser: true,
      }));
    } else {
      const bw = icon.bw ?? (icon.defWUnits ? Math.round(unitsToPx(icon.defWUnits)) : 90);
      const bh = icon.bh ?? (icon.defHUnits ? Math.round(unitsToPx(icon.defHUnits)) : 90);
      // power icon: set default voltage and distinctive color
      const extra = (icon.id === 'power_120v') ? { powerVoltage: icon.defVoltage || '120V', powerTextColor: '#000000', color: '#ffd54f' } : {};
      items.push(normalizeItem({
        id,
        kind: "icon",
        iconId: icon.id,
        name: icon.name,
        x: clampf(x, 0, stage.w), y: clampf(y, 0, stage.h),
        r: 0,
        s: s,
        sx: s,
        sy: s,
        label: "",
        labelSize: 14,
        labelColor: "#111111",
        locked: false,
        bw: bw,
        bh: bh,
        ...extra
      }));
    }
    pushHistory("add icon");
    draw();
    selectOnly([id]);
  }

  function addImageItemAt(dataUrl, fileName, x, y) {
    const id = uid();
    items.push(normalizeItem({
      id,
      kind: "image",
      name: fileName || "Image",
      x: clampf(x, 0, stage.w), y: clampf(y, 0, stage.h),
      r: 0, s: 1,
      href: dataUrl,
      iw: 220, ih: 220,
      locked: false,
      bw: 260, bh: 260,
      label: "",
      labelSize: 14,
      labelColor: "#111111",
    }));
    pushHistory("add image");
    draw();
    selectOnly([id]);
  }

  function addCableFromDraft() {
    if (!cableTool.draft || cableTool.draft.points.length < 2) return;
    const id = uid();
    const it = normalizeItem({
      id,
      kind: "cable",
      name: "Cable",
      points: cableTool.draft.points.map(p => ({ x: p.x, y: p.y })),
      color: cableTool.draft.color,
      width: cableTool.draft.width,
      locked: false,
      groupId: null,
    });
    items.push(it);
    cableTool.draft = null;
    selectOnly([id]);
    pushHistory("add cable");
    draw();
  }

  // ============================================================
  // SELECTION
  // ============================================================
  function isSelected(id) { return selected.has(id); }

  function getSelectedIds() { return Array.from(selected); }

  function getSelectedItems() {
    const ids = selected;
    return items.filter(x => ids.has(x.id));
  }

  function getSelected() {
    const ids = getSelectedIds();
    if (ids.length !== 1) return null;
    return getItemById(ids[0]);
  }

  function getItemById(id) { return items.find(x => x.id === id) || null; }

  function groupMembers(gid) { return items.filter(it => it.groupId === gid).map(it => it.id); }

  function selectOnly(ids) {
    selected = new Set(ids);
    primaryId = ids.length ? ids[0] : null;
    updateInspector();
    drawSelectionOverlay();
    renderLayers();
    updateStatus();
  }

  function toggleSelectionIds(ids, primary = null) {
    let allSelected = true;
    for (const id of ids) if (!selected.has(id)) { allSelected = false; break; }
    if (allSelected) {
      for (const id of ids) selected.delete(id);
    } else {
      for (const id of ids) selected.add(id);
    }
    primaryId = primary || (selected.size ? Array.from(selected)[0] : null);
    updateInspector();
    drawSelectionOverlay();
    renderLayers();
    updateStatus();
  }

  function clearSelection() {
    selected.clear();
    primaryId = null;
    drag.active = false;
    els.selection.setAttribute("visibility", "hidden");
    els.verts.innerHTML = "";
    updateInspector();
    renderLayers();
    updateStatus();
  }

  function selectFromClick(id, opts = {}) {
    const it = getItemById(id);
    if (!it) return;

    // Locked items are not selectable on canvas (layers menu can still select/unlock)
    if (opts.fromCanvas && it.locked) return;

    const ids = it.groupId ? groupMembers(it.groupId) : [id];
    if (opts.shift) {
      toggleSelectionIds(ids, id);
    } else {
      selectOnly(ids);
      primaryId = id;
    }
  }

  // ============================================================
  // STAGE SIZE / GRID / ZOOM
  // ============================================================
  function clampStage(n) { return clampf(n, 300, 6000); }

  function setStageSizePx(wPx, hPx) {
    stage.w = clampStage(wPx);
    stage.h = clampStage(hPx);
    // Clamp items into stage bounds
    for (const it of items) {
      if (it.kind === "cable") {
        for (const p of it.points) {
          p.x = clampf(p.x, 0, stage.w);
          p.y = clampf(p.y, 0, stage.h);
        }
      } else {
        it.x = clampf(it.x, 0, stage.w);
        it.y = clampf(it.y, 0, stage.h);
      }
    }
    draw();
  }

  function setStageFromInputs() {
    const wUnits = clampf(parseFloat(els.w.value || "40"), 1, 9999);
    const hUnits = clampf(parseFloat(els.h.value || "23"), 1, 9999);
    setStageSizePx(unitsToPx(wUnits), unitsToPx(hUnits));
    pushHistory("resize stage");
  }

  function applyZoom() {
    // If fullscreen, let fullscreen sizing handle the svg to preserve aspect
    if (root.classList && root.classList.contains('sp-fullscreen')) { try { adjustFullscreenCanvas(); } catch (err) {} return; }
    // Adjust the displayed SVG element so it keeps the stage aspect ratio
    // and allows the page to grow vertically (page scroll). Zoom scales
    // both width and height of the rendered viewport.
    const wrap = document.querySelector('.sp-canvasWrap');
    if (!wrap) return;
    const style = getComputedStyle(wrap);
    const padLeft = parseFloat(style.paddingLeft) || 0;
    const padRight = parseFloat(style.paddingRight) || 0;
    const availW = Math.max(20, wrap.clientWidth - padLeft - padRight);
    const baseH = (stage.h / Math.max(1, stage.w)) * availW;
    const z = clampf(num(stage.zoom, 1), 0.1, 10);
    const displayW = Math.max(1, availW * z);
    const displayH = Math.max(1, baseH * z);
    els.svg.style.width = displayW + 'px';
    els.svg.style.height = displayH + 'px';
  }

  function gridStepPx() {
    const gsUnits = clampf(parseFloat(els.gridSize.value || "1"), 0.1, 1000);
    return unitsToPx(gsUnits);
  }

  // ============================================================
  // DRAW
  // ============================================================
  function draw() {
    // viewBox
    els.svg.setAttribute("viewBox", `0 0 ${stage.w} ${stage.h}`);
    document.getElementById("sp-bg").setAttribute("width", stage.w);
    document.getElementById("sp-bg").setAttribute("height", stage.h);
    els.gridRect.setAttribute("width", stage.w);
    els.gridRect.setAttribute("height", stage.h);

    // grid
    const gs = gridStepPx();
    els.gridPattern.setAttribute("width", gs);
    els.gridPattern.setAttribute("height", gs);
    const path = els.gridPattern.querySelector("path");
    if (path) path.setAttribute("d", `M ${gs} 0 L 0 0 0 ${gs}`);
    els.gridRect.style.display = stage.showGrid ? "block" : "none";

    // items
    els.items.innerHTML = "";
    for (const it0 of items) {
      const it = normalizeItem(it0);
      // normalize in-place for safety
      Object.assign(it0, it);

      if (it.kind === "cable") els.items.appendChild(renderCable(it));
      else if (it.kind === "text") els.items.appendChild(renderText(it));
      else if (it.kind === "image") els.items.appendChild(renderImage(it));
      else if (it.kind === "shape") els.items.appendChild(renderShape(it));
      else els.items.appendChild(renderIcon(it));
    }

    drawCableDraft();
    drawSelectionOverlay();
    renderLayers();
    updateStatus();
    applyZoom();

    drawMidpointGuides();

    // pointer-events behavior
    // - locked items are not clickable (pass-through)
    // - cable tool ignores all items
    if (cableTool.on) els.items.style.pointerEvents = "none";
    else els.items.style.pointerEvents = "auto";
  }

  function labelYFor(it) {
    const size = clampf(num(it.labelSize, 14), 8, 72);
    let halfH = 40 * (it.s || 1);
    if (it.kind === "shape") halfH = (it.h * (it.s || 1)) / 2;
    if (it.kind === "image") halfH = (it.ih * (it.s || 1)) / 2;
    return it.y + halfH + size * 0.9 + 6;
  }

  function renderLabel(it) {
    if (!it.label) return "";
    const size = clampf(num(it.labelSize, 14), 8, 72);
    const color = it.labelColor || "#111111";
    const y = labelYFor(it);
    return `<text x="${it.x}" y="${y}" text-anchor="middle" font-size="${size}"
                 fill="${escapeAttr(color)}" pointer-events="none">${escapeXml(it.label)}</text>`;
  }

  function attachContextDelete(el, id) {
    // Right-click delete disabled (browser context menu preserved)
  }

  function renderIcon(it) {
    const g = svgEl("g");
    g.setAttribute("data-id", it.id);
    g.setAttribute("filter", "url(#sp-shadow)");
    g.style.cursor = it.locked ? "default" : "grab";
    g.style.opacity = it.locked ? "0.85" : "1";
    g.style.pointerEvents = it.locked ? "none" : "auto";

    const lib = findLibById(it.iconId);
    const groupSvg = lib && lib.svgGroup ? lib.svgGroup : makeTintableSvgGroup(baseBox("?"));

    // Use a smaller fixed hit box for icons to keep library thumbnails compact
    const hitSize = lib && lib.bw ? lib.bw : 72;
    const hit = `<rect x="${-hitSize/2}" y="${-hitSize/2}" width="${hitSize}" height="${hitSize}" fill="transparent"/>`;

    // Special rendering for power label icons so they stand out and display chosen voltage
    if (it.iconId === 'power_120v') {
      const bg = escapeAttr(it.color || '#ffd54f');
      const txt = escapeXml(it.powerVoltage || it.name || '120V');
      const txtCol = escapeAttr(it.powerTextColor || '#000000');
      g.innerHTML = `
        <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${it.s})">
          ${hit}
          <g transform="translate(-40 -21)">
            <rect x="0" y="0" width="80" height="42" rx="8" fill="${bg}" stroke="#111" stroke-width="1.5"/>
            <text x="40" y="27" text-anchor="middle" font-size="16" font-weight="700" fill="${txtCol}">${txt}</text>
          </g>
        </g>
        ${renderLabel(it)}
      `;
    } else {
      g.innerHTML = `
        <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${(it.sx||it.s)} ${(it.sy||it.s)})" style="color:${escapeAttr(it.color || defaultIconColor(it.iconId || ""))}">
          ${hit}
          <g transform="translate(-35 -35)">
            ${groupSvg}
          </g>
        </g>
        ${renderLabel(it)}
      `;
    }

    // If this is a riser icon (legacy items), render as a plain rectangle so on-canvas it matches shape risers
    if (it.iconId === 'riser') {
      const lib = findLibById(it.iconId) || {};
      const bw = it.bw || lib.svgBW || 60;
      const bh = it.bh || lib.svgBH || 35;
      const fill = it.fill || 'rgba(0,0,0,0.08)';
      const stroke = it.stroke || it.color || '#111111';
      const rect = `<rect x="${-bw/2}" y="${-bh/2}" width="${bw}" height="${bh}" rx="0" fill="${fill}" stroke="${stroke}" stroke-width="2"/>`;
      g.innerHTML = `
        <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${(it.sx||it.s)} ${(it.sy||it.s)})">
          ${hit}
          ${rect}
        </g>
        ${renderLabel(it)}
      `;
    }

    g.addEventListener("pointerdown", (e) => onItemPointerDown(e, it.id));
    attachContextDelete(g, it.id);
    return g;
  }

  function renderShape(it) {
    const g = svgEl("g");
    g.setAttribute("data-id", it.id);
    g.setAttribute("filter", "url(#sp-shadow)");
    g.style.cursor = it.locked ? "default" : "grab";
    g.style.opacity = it.locked ? "0.85" : "1";
    g.style.pointerEvents = it.locked ? "none" : "auto";

    const hit = `<rect x="${-it.w/2 - 24}" y="${-it.h/2 - 24}" width="${it.w + 48}" height="${it.h + 48}" fill="transparent"/>`;

    const fillAttr = (it.fill && it.fill !== "none") ? `fill="${escapeAttr(it.fill)}" fill-opacity="${clampf(num(it.fillOpacity,1),0,1)}"` : `fill="none"`;
    const strokeAttr = `stroke="${escapeAttr(it.stroke || "#111111")}" stroke-width="${clampf(num(it.strokeWidth,4),1,30)}"`;

    if (it.isRiser) {
      // Draw a precise rectangular riser (no rounded corners, no legs)
      const rectEl = `<rect x="${-it.w/2}" y="${-it.h/2}" width="${it.w}" height="${it.h}" rx="0" ${fillAttr} ${strokeAttr} />`;
      g.innerHTML = `
        <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${it.s})">
          ${hit}
          ${rectEl}
        </g>
        ${renderLabel(it)}
      `;
    } else {
      const shapeEl = it.shape === "circle"
        ? `<ellipse cx="0" cy="0" rx="${it.w/2}" ry="${it.h/2}" ${fillAttr} ${strokeAttr} />`
        : `<rect x="${-it.w/2}" y="${-it.h/2}" width="${it.w}" height="${it.h}" rx="0" ${fillAttr} ${strokeAttr} />`;

      g.innerHTML = `
        <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${it.s})">
          ${hit}
          ${shapeEl}
        </g>
        ${renderLabel(it)}
      `;
    }

    g.addEventListener("pointerdown", (e) => onItemPointerDown(e, it.id));
    attachContextDelete(g, it.id);
    return g;
  }

  function renderText(it) {
    const g = svgEl("g");
    g.setAttribute("data-id", it.id);
    g.style.cursor = it.locked ? "default" : "grab";
    g.style.opacity = it.locked ? "0.85" : "1";
    g.style.pointerEvents = it.locked ? "none" : "auto";

    const hit = `<rect x="-160" y="-50" width="320" height="100" fill="transparent"/>`;

    g.innerHTML = `
      <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${it.s})">
        ${hit}
        <text x="0" y="0" text-anchor="middle" dominant-baseline="middle"
              font-size="${it.fontSize}" fill="${escapeAttr(it.color || "#111111")}">${escapeXml(it.text || "")}</text>
      </g>
    `;

    g.addEventListener("pointerdown", (e) => onItemPointerDown(e, it.id));
    attachContextDelete(g, it.id);
    return g;
  }

  function renderImage(it) {
    const g = svgEl("g");
    g.setAttribute("data-id", it.id);
    g.style.cursor = it.locked ? "default" : "grab";
    g.style.opacity = it.locked ? "0.85" : "1";
    g.style.pointerEvents = it.locked ? "none" : "auto";

    const w = it.iw, h = it.ih;

    g.innerHTML = `
      <g transform="translate(${it.x} ${it.y}) rotate(${it.r}) scale(${it.s})">
        <rect x="${-w/2 - 20}" y="${-h/2 - 20}" width="${w+40}" height="${h+40}" fill="transparent"/>
        <image href="${it.href}" x="${-w/2}" y="${-h/2}" width="${w}" height="${h}" preserveAspectRatio="xMidYMid meet"/>
        <rect x="${-w/2}" y="${-h/2}" width="${w}" height="${h}" fill="none" stroke="rgba(0,0,0,0.18)" />
      </g>
      ${renderLabel(it)}
    `;

    g.addEventListener("pointerdown", (e) => onItemPointerDown(e, it.id));
    attachContextDelete(g, it.id);
    return g;
  }

  function renderCable(it) {
    const g = svgEl("g");
    g.setAttribute("data-id", it.id);
    g.style.cursor = it.locked ? "default" : "grab";
    g.style.opacity = it.locked ? "0.85" : "1";
    g.style.pointerEvents = it.locked ? "none" : "auto";

    const pts = it.points.map(p => `${p.x},${p.y}`).join(" ");
    const fat = Math.max(14, it.width * 5);
    g.innerHTML = `
      <polyline points="${pts}" fill="none" stroke="transparent" stroke-width="${fat}" stroke-linecap="round" stroke-linejoin="round"/>
      <polyline points="${pts}" fill="none" stroke="${escapeAttr(it.color)}" stroke-width="${it.width}" stroke-linecap="round" stroke-linejoin="round"/>
    `;
    g.addEventListener("pointerdown", (e) => onItemPointerDown(e, it.id));
    attachContextDelete(g, it.id);
    return g;
  }

  // ============================================================
  // SELECTION OVERLAY (accurate bbox)
  // ============================================================
  function getRenderedEl(id) {
    try {
      return els.items.querySelector(`[data-id="${cssEscape(id)}"]`);
    } catch (_) {
      return els.items.querySelector(`[data-id="${id.replace(/"/g, '\\"')}"]`);
    }
  }

  function getTransformedBBox(el) {
    try {
      const bb = el.getBBox();

      // Convert bbox corners into SVG user units reliably (handles viewBox/CSS zoom)
      const elM = el.getScreenCTM ? el.getScreenCTM() : null;
      const svgM = els.svg && els.svg.getScreenCTM ? els.svg.getScreenCTM() : null;

      // Fallback: bb is already in SVG user units in most cases
      if (!elM || !svgM) return { x: bb.x, y: bb.y, width: bb.width, height: bb.height };

      const inv = svgM.inverse();

      const cornersScreen = [
        transformPoint(bb.x, bb.y, elM),
        transformPoint(bb.x + bb.width, bb.y, elM),
        transformPoint(bb.x, bb.y + bb.height, elM),
        transformPoint(bb.x + bb.width, bb.y + bb.height, elM),
      ];
      const corners = cornersScreen.map(p => transformPoint(p.x, p.y, inv));

      const xs = corners.map(p => p.x);
      const ys = corners.map(p => p.y);
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      return { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
    } catch (_) {
      return null;
    }
  }


  function drawSelectionOverlay() {
    els.verts.innerHTML = "";

    if (selected.size === 0) {
      els.selection.setAttribute("visibility","hidden");
      return;
    }

    const ids = getSelectedIds();

    // If exactly one cable selected: show vertices, hide bbox
    if (ids.length === 1) {
      const it = getItemById(ids[0]);
      if (it && it.kind === "cable") {
        els.selection.setAttribute("visibility","hidden");
        it.points.forEach((p, idx) => {
          const c = svgEl("circle");
          c.setAttribute("cx", p.x);
          c.setAttribute("cy", p.y);
          c.setAttribute("r", 7);
          c.setAttribute("fill", "rgba(0,120,255,0.95)");
          c.setAttribute("stroke", "white");
          c.setAttribute("stroke-width", "2");
          c.style.cursor = it.locked || cableTool.on ? "default" : "move";
          c.style.pointerEvents = (it.locked || cableTool.on) ? "none" : "auto";
          c.addEventListener("pointerdown", (e) => onVertexPointerDown(e, it.id, idx));
          els.verts.appendChild(c);
        });
        return;
      }
    }

    // Multi or non-cable: show union bbox
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const id of ids) {
      const el = getRenderedEl(id);
      if (!el) continue;
      const bb = getTransformedBBox(el);
      if (!bb) continue;
      minX = Math.min(minX, bb.x);
      minY = Math.min(minY, bb.y);
      maxX = Math.max(maxX, bb.x + bb.width);
      maxY = Math.max(maxY, bb.y + bb.height);
    }

    if (!isFinite(minX) || !isFinite(minY) || !isFinite(maxX) || !isFinite(maxY)) {
      els.selection.setAttribute("visibility","hidden");
      return;
    }

    const pad = 2; // tightened selection padding
    els.selRect.setAttribute("x", minX - pad);
    els.selRect.setAttribute("y", minY - pad);
    els.selRect.setAttribute("width", (maxX - minX) + pad * 2);
    els.selRect.setAttribute("height", (maxY - minY) + pad * 2);
    els.selection.setAttribute("visibility","visible");
  }

  // ============================================================
  // STATUS
  // ============================================================
  function updateStatus() {
    const ids = getSelectedIds();
    if (ids.length === 0) {
      els.status.textContent = "No selection";
      return;
    }
    if (ids.length > 1) {
      const locked = getSelectedItems().every(it => !!it.locked);
      els.status.textContent = `Selected: ${ids.length} items • ${locked ? "Locked" : "Unlocked"}`;
      return;
    }
    const it = getItemById(ids[0]);
    if (!it) { els.status.textContent = "No selection"; return; }
    if (it.kind === "cable") {
      els.status.textContent = `Cable • points:${it.points.length} • width:${it.width} • ${it.locked ? "Locked" : "Unlocked"}`;
      return;
    }
    els.status.textContent = `${it.name || it.kind} • x:${Math.round(it.x)} y:${Math.round(it.y)} • r:${Math.round(it.r||0)}° • s:${round2(it.s||1)} • ${it.locked ? "Locked" : "Unlocked"}`;
  }

  // ============================================================
  // INSPECTOR
  // ============================================================
  function updateInspector() {
    const ids = getSelectedIds();

    // buttons enabled state
    const hasSel = ids.length > 0;
    if (els.deleteBtn) els.deleteBtn.disabled = !hasSel;
    if (els.lockBtn) els.lockBtn.disabled = !hasSel;
    if (els.duplicateBtn) els.duplicateBtn.disabled = !hasSel;
    if (els.groupBtn) els.groupBtn.disabled = ids.length < 2;
    if (els.ungroupBtn) els.ungroupBtn.disabled = !hasSel;

    if (!hasSel) {
      els.inspectorFields.innerHTML = "";
      if (els.lockBtn) {
        els.lockBtn.setAttribute("aria-pressed","false");
        els.lockBtn.textContent = "Lock";
      }
      return;
    }

    const selectedItems = getSelectedItems();

    // Multi-selection inspector
    if (ids.length > 1) {
      const allLocked = selectedItems.every(it => !!it.locked);
      if (els.lockBtn) {
        els.lockBtn.setAttribute("aria-pressed", allLocked ? "true" : "false");
        els.lockBtn.textContent = allLocked ? "Unlock" : "Lock";
      }

      // If all share same groupId, show group name + rename
      const gid = selectedItems[0].groupId;
      const sameGroup = gid && selectedItems.every(it => it.groupId === gid);
      const name = sameGroup ? (groups[gid]?.name || "Group") : "";

      els.inspectorFields.innerHTML = `
        <div class="sp-field">
          <div>${sameGroup ? "Group" : "Multiple selection"}</div>
          <div class="sp-muted">${sameGroup ? escapeHtml(name) : `${ids.length} items selected`}</div>
        </div>
        ${sameGroup ? `
        <div class="sp-field">
          <div>Group name</div>
          <input id="sp-f-gname" value="${escapeAttr(name)}" />
        </div>` : ``}
      `;

      if (sameGroup) {
        const gname = document.getElementById("sp-f-gname");
        gname.addEventListener("input", (e) => {
          groups[gid] = groups[gid] || { name: "Group" };
          groups[gid].name = e.target.value || "Group";
          draw();
          debounceHistory("rename group");
        });
      }
      return;
    }

    // Single selection inspector
    const it = selectedItems[0];
    if (!it) return;

    const quickAdjustHtml = `
      <div class="sp-row" id="sp-quickAdjust">
        <button id="sp-qaScaleDown" class="sp-btn sp-mini">Scale −</button>
        <button id="sp-qaScaleUp" class="sp-btn sp-mini">Scale +</button>

        <button id="sp-qaFontDown" class="sp-btn sp-mini">Font −</button>
        <button id="sp-qaFontUp" class="sp-btn sp-mini">Font +</button>

        <button id="sp-qaWDown" class="sp-btn sp-mini">W −</button>
        <button id="sp-qaWUp" class="sp-btn sp-mini">W +</button>

        <button id="sp-qaHDown" class="sp-btn sp-mini">H −</button>
        <button id="sp-qaHUp" class="sp-btn sp-mini">H +</button>
      </div>
    `;

    if (els.lockBtn) {
      els.lockBtn.setAttribute("aria-pressed", it.locked ? "true" : "false");
      els.lockBtn.textContent = it.locked ? "Unlock" : "Lock";
    }

    if (it.kind === "icon") {
      els.inspectorFields.innerHTML = `${quickAdjustHtml}
        <div class="sp-field">
          <div>Label</div>
          <div class="sp-inline">
            <input id="sp-f-label" placeholder="e.g., Vox 1" value="${escapeAttr(it.label || "")}"/>
            <label>Size <input id="sp-f-labelSize" type="number" min="8" max="72" step="1" value="${Math.round(it.labelSize||14)}"/></label>
            <label>Color <input id="sp-f-labelColor" type="color" value="${toColorInput(it.labelColor || "#111111")}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div>Icon color</div>
          <input id="sp-f-color" type="color" value="${toColorInput(it.color || "#111111")}"/>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Scale <input id="sp-f-scale" type="number" step="0.05" min="0.2" max="8" value="${round2(it.s||1)}"/></label>
            <label>Rotate <input id="sp-f-rot" type="number" step="1" value="${Math.round(it.r||0)}"/></label>
          </div>
        </div>
      `;
      hookCommonTransforms(it);
      hookLabelFields(it);
      const color = document.getElementById("sp-f-color");
      color.addEventListener("input", (e) => { it.color = e.target.value; draw(); debounceHistory("icon color"); });
      // Power icon inspector controls
      if (it.iconId === 'power_120v') {
        const voltHtml = `
          <div class="sp-field">
            <div>Power label</div>
            <div class="sp-inline">
              <select id="sp-f-powerVoltage">
                <option value="120V">120V</option>
                <option value="208V">208V</option>
                <option value="220V">220V</option>
                <option value="230V">230V</option>
                <option value="240V">240V</option>
                <option value="custom">Custom</option>
              </select>
              <input id="sp-f-powerCustom" placeholder="Custom label" style="width:120px;" />
              <label>Text color <input id="sp-f-powerTextColor" type="color" value="#000000"/></label>
            </div>
          </div>`;
        els.inspectorFields.insertAdjacentHTML('beforeend', voltHtml);
        const sel = document.getElementById('sp-f-powerVoltage');
        const custom = document.getElementById('sp-f-powerCustom');
        const textCol = document.getElementById('sp-f-powerTextColor');
        // initialize
        if (!it.powerVoltage) it.powerVoltage = it.powerVoltage || (findLibById(it.iconId)?.defVoltage || it.name || '120V');
        if (!it.powerTextColor) it.powerTextColor = it.powerTextColor || '#000000';
        if (sel) {
          sel.value = ['120V','208V','220V','230V','240V'].includes(it.powerVoltage) ? it.powerVoltage : 'custom';
        }
        if (custom) custom.value = ['120V','208V','220V','230V','240V'].includes(it.powerVoltage) ? '' : it.powerVoltage;
        if (textCol) textCol.value = it.powerTextColor;
        if (sel) sel.addEventListener('change', (e)=>{
          const v = e.target.value;
          if (v === 'custom') {
            // keep current custom in input
            it.powerVoltage = custom.value || '';
          } else {
            it.powerVoltage = v;
            if (custom) custom.value = '';
          }
          draw(); debounceHistory('power label');
        });
        if (custom) custom.addEventListener('input', (e)=>{ it.powerVoltage = e.target.value || ''; draw(); debounceHistory('power custom'); });
        if (textCol) textCol.addEventListener('input', (e)=>{ it.powerTextColor = e.target.value; draw(); debounceHistory('power text color'); });
      }
      // Riser-specific size controls (edit width/height in current units)
      if (it.iconId === 'riser') {
        const iconMeta = findLibById(it.iconId) || {};
        const svgBW = iconMeta.svgBW || 70;
        const svgBH = iconMeta.svgBH || 70;
        const curW = round2(pxToUnits((it.sx || it.s || 1) * svgBW));
        const curH = round2(pxToUnits((it.sy || it.s || 1) * svgBH));
        const unitsLabel = (els.units && els.units.value === 'm') ? 'm' : 'ft';
        const riserHtml = `
          <div class="sp-field">
            <div>Riser size (${unitsLabel})</div>
            <div class="sp-inline">
              <label>W <input id="sp-f-riser-w" type="number" step="0.1" min="0.1" value="${curW}"/></label>
              <label>H <input id="sp-f-riser-h" type="number" step="0.1" min="0.1" value="${curH}"/></label>
              <button id="sp-f-riser-preset" class="sp-btn sp-mini">Preset</button>
            </div>
          </div>`;
        els.inspectorFields.insertAdjacentHTML('beforeend', riserHtml);
        const elW = document.getElementById('sp-f-riser-w');
        const elH = document.getElementById('sp-f-riser-h');
        if (elW) elW.addEventListener('input', (e) => {
          const nw = clampf(parseFloat(e.target.value||'0.1'), 0.1, 9999);
          const newSx = unitsToPx(nw) / svgBW;
          it.sx = newSx;
          // keep sy stable
          draw(); debounceHistory('riser size');
        });
        if (elH) elH.addEventListener('input', (e) => {
          const nh = clampf(parseFloat(e.target.value||'0.1'), 0.1, 9999);
          const newSy = unitsToPx(nh) / svgBH;
          it.sy = newSy;
          draw(); debounceHistory('riser size');
        });
        const preset = document.getElementById('sp-f-riser-preset');
        if (preset) preset.addEventListener('click', () => {
          // cycle common presets: 4x8, 4x4, 6x8
          const presets = [[8,4],[4,4],[8,6]];
          const cur = [round2(pxToUnits((it.sx||it.s||1)*svgBW)), round2(pxToUnits((it.sy||it.s||1)*svgBH))];
          let idx = presets.findIndex(p => p[0]===cur[0] && p[1]===cur[1]); idx = (idx+1) % presets.length;
          const [pw, ph] = presets[idx];
          if (elW) elW.value = pw; if (elH) elH.value = ph;
          it.sx = unitsToPx(pw) / svgBW; it.sy = unitsToPx(ph) / svgBH;
          draw(); debounceHistory('riser preset');
        });
      }
      attachQuickAdjust();
      return;
    }

    if (it.kind === "shape") {
      const fillOn = (it.fill && it.fill !== "none");
      els.inspectorFields.innerHTML = `${quickAdjustHtml}
        <div class="sp-field">
          <div>Label</div>
          <div class="sp-inline">
            <input id="sp-f-label" placeholder="optional" value="${escapeAttr(it.label || "")}"/>
            <label>Size <input id="sp-f-labelSize" type="number" min="8" max="72" step="1" value="${Math.round(it.labelSize||14)}"/></label>
            <label>Color <input id="sp-f-labelColor" type="color" value="${toColorInput(it.labelColor || "#111111")}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Stroke <input id="sp-f-stroke" type="color" value="${toColorInput(it.stroke || "#111111")}"/></label>
            <label>Width <input id="sp-f-strokeW" type="number" min="1" max="30" step="1" value="${Math.round(it.strokeWidth||4)}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label><input id="sp-f-fillOn" type="checkbox" ${fillOn ? "checked":""}/> Fill</label>
            <input id="sp-f-fill" type="color" value="${toColorInput(fillOn ? it.fill : "#ffffff")}"/>
            <label>Opacity <input id="sp-f-fillOp" type="number" min="0" max="1" step="0.05" value="${round2(it.fillOpacity ?? 1)}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
          ${it.isRiser ? (() => {
            const iconMeta = findLibById(it.iconId) || {};
            const svgBW = iconMeta.svgBW || 70;
            const svgBH = iconMeta.svgBH || 70;
            const curW = round2(pxToUnits(it.w || svgBW));
            const curH = round2(pxToUnits(it.h || svgBH));
            const unitsLabel = (els.units && els.units.value === 'm') ? 'm' : 'ft';
            return `
              <div>Riser size (${unitsLabel})</div>
              <div class="sp-inline">
                <label>W <input id="sp-f-w" type="number" step="0.1" min="0.1" value="${curW}"/></label>
                <label>H <input id="sp-f-h" type="number" step="0.1" min="0.1" value="${curH}"/></label>
                <button id="sp-f-riser-preset" class="sp-btn sp-mini">Preset</button>
              </div>
            `;
          })() : `
            <label>W <input id="sp-f-w" type="number" min="20" max="4000" step="10" value="${Math.round(it.w||200)}"/></label>
            <label>H <input id="sp-f-h" type="number" min="20" max="4000" step="10" value="${Math.round(it.h||200)}"/></label>
          `}
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Scale <input id="sp-f-scale" type="number" step="0.05" min="0.2" max="8" value="${round2(it.s||1)}"/></label>
            <label>Rotate <input id="sp-f-rot" type="number" step="1" value="${Math.round(it.r||0)}"/></label>
          </div>
        </div>
      `;

      hookCommonTransforms(it);
      hookLabelFields(it);

      document.getElementById("sp-f-stroke").addEventListener("input", (e) => { it.stroke = e.target.value; draw(); debounceHistory("shape stroke"); });
      document.getElementById("sp-f-strokeW").addEventListener("input", (e) => { it.strokeWidth = clampf(parseFloat(e.target.value||"4"),1,30); draw(); debounceHistory("shape stroke width"); });

      const fillOnEl = document.getElementById("sp-f-fillOn");
      const fillEl = document.getElementById("sp-f-fill");
      const fillOpEl = document.getElementById("sp-f-fillOp");

      fillOnEl.addEventListener("change", () => {
        if (fillOnEl.checked) it.fill = fillEl.value;
        else it.fill = "none";
        draw();
        pushHistory("shape fill toggle");
      });
      fillEl.addEventListener("input", (e) => {
        if (fillOnEl.checked) it.fill = e.target.value;
        draw();
        debounceHistory("shape fill color");
      });
      fillOpEl.addEventListener("input", (e) => {
        it.fillOpacity = clampf(parseFloat(e.target.value||"1"), 0, 1);
        draw();
        debounceHistory("shape fill opacity");
      });

      // Hook riser W/H inputs (units) if this shape is a riser
      if (it.isRiser) {
        const elW = document.getElementById('sp-f-w');
        const elH = document.getElementById('sp-f-h');
        if (elW) elW.addEventListener('input', (e) => {
          const nw = clampf(parseFloat(e.target.value||'0.1'), 0.1, 9999);
          it.w = clampf(unitsToPx(nw), 10, 4000);
          draw(); debounceHistory('riser size');
        });
        if (elH) elH.addEventListener('input', (e) => {
          const nh = clampf(parseFloat(e.target.value||'0.1'), 0.1, 9999);
          it.h = clampf(unitsToPx(nh), 10, 4000);
          draw(); debounceHistory('riser size');
        });
        const presetBtn = document.getElementById('sp-f-riser-preset');
        if (presetBtn) presetBtn.addEventListener('click', () => {
          const presets = [[8,4],[4,4],[8,6]];
          const cur = [round2(pxToUnits(it.w||0)), round2(pxToUnits(it.h||0))];
          let idx = presets.findIndex(p => p[0]===cur[0] && p[1]===cur[1]); idx = (idx+1) % presets.length;
          const [pw, ph] = presets[idx];
          if (elW) elW.value = pw; if (elH) elH.value = ph;
          it.w = unitsToPx(pw); it.h = unitsToPx(ph);
          draw(); debounceHistory('riser preset');
        });
      } else {
        // non-riser shape W/H hooks
        const elW = document.getElementById('sp-f-w');
        const elH = document.getElementById('sp-f-h');
        if (elW) elW.addEventListener('input', (e) => { it.w = clampf(parseFloat(e.target.value||'20'),20,4000); draw(); debounceHistory('shape width'); });
        if (elH) elH.addEventListener('input', (e) => { it.h = clampf(parseFloat(e.target.value||'20'),20,4000); draw(); debounceHistory('shape height'); });
      }
      attachQuickAdjust();
      return;
    }

    if (it.kind === "text") {
      els.inspectorFields.innerHTML = `${quickAdjustHtml}
        <div class="sp-field">
          <div>Text</div>
          <textarea id="sp-f-text">${escapeHtml(it.text || "")}</textarea>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Color <input id="sp-f-color" type="color" value="${toColorInput(it.color || "#111111")}"/></label>
            <label>Size <input id="sp-f-font" type="number" step="1" min="8" max="200" value="${Math.round(it.fontSize||24)}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Scale <input id="sp-f-scale" type="number" step="0.05" min="0.2" max="8" value="${round2(it.s||1)}"/></label>
            <label>Rotate <input id="sp-f-rot" type="number" step="1" value="${Math.round(it.r||0)}"/></label>
          </div>
        </div>
      `;

      document.getElementById("sp-f-text").addEventListener("input", (e) => { it.text = e.target.value; draw(); debounceHistory("text"); });
      document.getElementById("sp-f-font").addEventListener("input", (e) => { it.fontSize = clampf(parseFloat(e.target.value||"24"), 8, 200); draw(); debounceHistory("text size"); });
      document.getElementById("sp-f-color").addEventListener("input", (e) => { it.color = e.target.value; draw(); debounceHistory("text color"); });
      hookCommonTransforms(it);
      attachQuickAdjust();
      return;
    }

    if (it.kind === "image") {
      els.inspectorFields.innerHTML = `${quickAdjustHtml}
        <div class="sp-field">
          <div>Image</div>
          <div class="sp-muted">${escapeHtml(it.name || "Image")}</div>
        </div>

        <div class="sp-field">
          <div>Label</div>
          <div class="sp-inline">
            <input id="sp-f-label" placeholder="optional" value="${escapeAttr(it.label || "")}"/>
            <label>Size <input id="sp-f-labelSize" type="number" min="8" max="72" step="1" value="${Math.round(it.labelSize||14)}"/></label>
            <label>Color <input id="sp-f-labelColor" type="color" value="${toColorInput(it.labelColor || "#111111")}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>W <input id="sp-f-iw" type="number" step="10" min="30" max="4000" value="${Math.round(it.iw||220)}"/></label>
            <label>H <input id="sp-f-ih" type="number" step="10" min="30" max="4000" value="${Math.round(it.ih||220)}"/></label>
          </div>
        </div>

        <div class="sp-field">
          <div class="sp-inline">
            <label>Scale <input id="sp-f-scale" type="number" step="0.05" min="0.2" max="8" value="${round2(it.s||1)}"/></label>
            <label>Rotate <input id="sp-f-rot" type="number" step="1" value="${Math.round(it.r||0)}"/></label>
          </div>
        </div>
      `;

      hookCommonTransforms(it);
      hookLabelFields(it);

      document.getElementById("sp-f-iw").addEventListener("input", (e) => { it.iw = clampf(parseFloat(e.target.value||"220"), 30, 4000); draw(); debounceHistory("image size"); });
      document.getElementById("sp-f-ih").addEventListener("input", (e) => { it.ih = clampf(parseFloat(e.target.value||"220"), 30, 4000); draw(); debounceHistory("image size"); });
      attachQuickAdjust();
      return;
    }

    if (it.kind === "cable") {
      els.inspectorFields.innerHTML = `
        <div class="sp-field">
          <div class="sp-inline">
            <label>Color <input id="sp-f-ccolor" type="color" value="${toColorInput(it.color || "#111111")}"/></label>
            <label>Width <input id="sp-f-cwidth" type="number" min="1" max="20" value="${Math.round(it.width||3)}"/></label>
          </div>
          <div class="sp-muted">Edit shape by dragging blue vertices (tool Off).</div>
        </div>
      `;
      document.getElementById("sp-f-ccolor").addEventListener("input", (e) => { it.color = e.target.value; draw(); debounceHistory("cable color"); });
      document.getElementById("sp-f-cwidth").addEventListener("input", (e) => { it.width = clampf(parseFloat(e.target.value||"3"), 1, 20); draw(); debounceHistory("cable width"); });
      // quick-adjust buttons state
      const _it = getSelected();
      const hasSel = !!_it;
      const canScale = hasSel && _it.kind !== "cable";
      const canFont = hasSel && _it.kind === "text";
      const canWH = hasSel && (_it.kind === "image" || _it.kind === "shape");

      if (els.qaScaleDown) els.qaScaleDown.disabled = !canScale;
      if (els.qaScaleUp) els.qaScaleUp.disabled = !canScale;
      if (els.qaFontDown) els.qaFontDown.disabled = !canFont;
      if (els.qaFontUp) els.qaFontUp.disabled = !canFont;
      if (els.qaWDown) els.qaWDown.disabled = !canWH;
      if (els.qaWUp) els.qaWUp.disabled = !canWH;
      if (els.qaHDown) els.qaHDown.disabled = !canWH;
      if (els.qaHUp) els.qaHUp.disabled = !canWH;

      return;
    }

    // quick-adjust buttons state for non-cable selections
    const _it2 = getSelected();
    const _hasSel = !!_it2;
    const _canScale = _hasSel && _it2.kind !== "cable";
    const _canFont = _hasSel && _it2.kind === "text";
    const _canWH = _hasSel && (_it2.kind === "image" || _it2.kind === "shape");

    if (els.qaScaleDown) els.qaScaleDown.disabled = !_canScale;
    if (els.qaScaleUp) els.qaScaleUp.disabled = !_canScale;
    if (els.qaFontDown) els.qaFontDown.disabled = !_canFont;
    if (els.qaFontUp) els.qaFontUp.disabled = !_canFont;
    if (els.qaWDown) els.qaWDown.disabled = !_canWH;
    if (els.qaWUp) els.qaWUp.disabled = !_canWH;
    if (els.qaHDown) els.qaHDown.disabled = !_canWH;
    if (els.qaHUp) els.qaHUp.disabled = !_canWH;
  }

  function hookCommonTransforms(it) {
    const elScale = document.getElementById("sp-f-scale");
    const elRot = document.getElementById("sp-f-rot");
    if (elScale) elScale.addEventListener("input", (e) => { const v = clampf(parseFloat(e.target.value||"1"), 0.2, 8); it.s = v; it.sx = v; it.sy = v; draw(); debounceHistory("scale"); });
    if (elRot) elRot.addEventListener("input", (e) => { it.r = mod(parseFloat(e.target.value||"0"), 360); draw(); debounceHistory("rotate"); });
  }

  function hookLabelFields(it) {
    const elLabel = document.getElementById("sp-f-label");
    const elLS = document.getElementById("sp-f-labelSize");
    const elLC = document.getElementById("sp-f-labelColor");
    if (elLabel) elLabel.addEventListener("input", (e) => { it.label = e.target.value; draw(); debounceHistory("label"); });
    if (elLS) elLS.addEventListener("input", (e) => { it.labelSize = clampf(parseFloat(e.target.value||"14"), 8, 72); draw(); debounceHistory("label size"); });
    if (elLC) elLC.addEventListener("input", (e) => { it.labelColor = e.target.value; draw(); debounceHistory("label color"); });
  }

  // ============================================================
  // LAYERS (with groups)
  // ============================================================
  function renderLayers() {
    if (!els.layerList) return;
    els.layerList.innerHTML = "";

    // Iterate from front to back for display
    for (let i = items.length - 1; i >= 0; ) {
      const it = items[i];
      if (it.groupId) {
        const gid = it.groupId;
        // find contiguous block
        let start = i;
        while (start - 1 >= 0 && items[start - 1].groupId === gid) start--;
        let end = i;
        while (end + 1 < items.length && items[end + 1].groupId === gid) end++;

        const memberIds = items.slice(start, end + 1).map(x => x.id);
        const allSel = memberIds.every(id => selected.has(id));
        const anyLocked = items.slice(start, end + 1).some(x => x.locked);
        const allLocked = items.slice(start, end + 1).every(x => x.locked);
        const gname = groups[gid]?.name || `Group ${gid.slice(-4)}`;

        const groupRow = document.createElement("div");
        groupRow.className = "sp-layerRow sp-groupRow" + (allSel ? " selected" : "");
        groupRow.innerHTML = `
          <div class="sp-layerLeft">
            <div class="sp-layerName">${escapeHtml(gname)}</div>
            <div class="sp-layerMeta">group • ${end-start+1} items${anyLocked ? (allLocked ? " • locked" : " • mixed lock") : ""}</div>
          </div>
          <div class="sp-layerBtns">
            <button class="sp-btn sp-mini" data-act="collapse">${ui.groupCollapsed[gid] ? "▸" : "▾"}</button>
            <button class="sp-btn sp-mini" data-act="up">▲</button>
            <button class="sp-btn sp-mini" data-act="down">▼</button>
            <button class="sp-btn sp-mini" data-act="lock">${allLocked ? "🔒" : "🔓"}</button>
            <button class="sp-btn sp-mini" data-act="dup">⧉</button>
            <button class="sp-btn sp-mini" data-act="del">✕</button>
          </div>
        `;
        groupRow.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          if (!btn) { selectOnly(memberIds); primaryId = memberIds[memberIds.length-1]; root.focus(); return; }
          e.stopPropagation();
          const act = btn.getAttribute("data-act");
          if (act === "collapse") { ui.groupCollapsed[gid] = !ui.groupCollapsed[gid]; renderLayers(); return; }
          if (act === "del") { deleteIds(memberIds); pushHistory("delete group"); draw(); return; }
          if (act === "dup") { duplicateIds(memberIds, true); return; }
          if (act === "lock") { setLockForIds(memberIds, !allLocked); pushHistory("lock group"); draw(); return; }
          if (act === "up") { moveBlockForward(start, end); pushHistory("move group forward"); draw(); return; }
          if (act === "down") { moveBlockBackward(start, end); pushHistory("move group backward"); draw(); return; }
        });
        els.layerList.appendChild(groupRow);

        if (!ui.groupCollapsed[gid]) {
          // children from front to back within block
          for (let j = end; j >= start; j--) {
            const child = items[j];
            const childRow = document.createElement("div");
            childRow.className = "sp-layerRow sp-childRow" + (selected.has(child.id) ? " selected" : "");
            const label = layerLabel(child);
            childRow.innerHTML = `
              <div class="sp-layerLeft">
                <div class="sp-layerName">— ${escapeHtml(label)}</div>
                <div class="sp-layerMeta">${escapeHtml(child.kind)}${child.locked ? " • locked" : ""}</div>
              </div>
              <div class="sp-layerBtns">
                <button class="sp-btn sp-mini" data-act="lock">${child.locked ? "🔒" : "🔓"}</button>
                <button class="sp-btn sp-mini" data-act="del">✕</button>
              </div>
            `;
            childRow.addEventListener("click", (e) => {
              const btn = e.target.closest("button");
              if (!btn) { selectOnly(memberIds); primaryId = child.id; root.focus(); return; }
              e.stopPropagation();
              const act = btn.getAttribute("data-act");
              if (act === "del") { deleteIds([child.id]); pushHistory("delete"); draw(); return; }
              if (act === "lock") { setLockForIds([child.id], !child.locked); pushHistory("lock"); draw(); return; }
            });
            els.layerList.appendChild(childRow);
          }
        }

        i = start - 1;
      } else {
        const row = document.createElement("div");
        row.className = "sp-layerRow" + (selected.has(it.id) ? " selected" : "");
        row.innerHTML = `
          <div class="sp-layerLeft">
            <div class="sp-layerName">${escapeHtml(layerLabel(it))}</div>
            <div class="sp-layerMeta">${escapeHtml(it.kind)}${it.locked ? " • locked" : ""}</div>
          </div>
          <div class="sp-layerBtns">
            <button class="sp-btn sp-mini" data-act="up">▲</button>
            <button class="sp-btn sp-mini" data-act="down">▼</button>
            <button class="sp-btn sp-mini" data-act="lock">${it.locked ? "🔒" : "🔓"}</button>
            <button class="sp-btn sp-mini" data-act="dup">⧉</button>
            <button class="sp-btn sp-mini" data-act="del">✕</button>
          </div>
        `;

        row.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          if (!btn) { selectFromClick(it.id, { shift: e.shiftKey, fromCanvas: false }); root.focus(); return; }
          e.stopPropagation();
          const act = btn.getAttribute("data-act");
          const idx = items.findIndex(x => x.id === it.id);
          if (act === "del") { deleteIds([it.id]); pushHistory("delete"); draw(); return; }
          if (act === "dup") { duplicateIds([it.id], false); return; }
          if (act === "lock") { setLockForIds([it.id], !it.locked); pushHistory("lock"); draw(); return; }
          if (act === "up") { moveOneForward([it.id]); pushHistory("bring forward"); draw(); return; }
          if (act === "down") { moveOneBackward([it.id]); pushHistory("send back"); draw(); return; }
        });

        els.layerList.appendChild(row);
        i--;
      }
    }
  }

  function layerLabel(it) {
    if (it.kind === "icon") return it.label ? `${it.name} — ${it.label}` : it.name;
    if (it.kind === "text") return it.text ? `Text — ${it.text}` : "Text";
    if (it.kind === "image") return `Image — ${it.name || "Image"}`;
    if (it.kind === "shape") return it.label ? `${it.name} — ${it.label}` : it.name;
    return "Cable";
  }

  // ============================================================
  // POINTER INTERACTIONS
  // ============================================================
  function onItemPointerDown(e, id) {
    if (cableTool.on) return; // cable tool ignores items
    e.preventDefault();
    e.stopPropagation();
    root.focus();

    selectFromClick(id, { shift: e.shiftKey, fromCanvas: true });

    // Start drag only if the clicked item is currently selected
    if (!selected.has(id)) return;

    const idsToDrag = getSelectedIds();
    if (idsToDrag.length === 0) return;

    // If any selected is locked, don't drag (and locked ones are not clickable anyway)
    if (idsToDrag.some(xid => (getItemById(xid)?.locked))) return;

    const p0 = svgPointFromEvent(e);
    drag.active = true;
    drag.mode = "move";
    drag.pointerId = e.pointerId;
    drag.start = p0;
    drag.ids = idsToDrag.slice();
    drag.primaryId = id;
    drag.originals = new Map();
    for (const xid of drag.ids) {
      const it = getItemById(xid);
      if (!it) continue;
      drag.originals.set(xid, deepClone(it));
    }

    els.svg.setPointerCapture(e.pointerId);
  }

  function onVertexPointerDown(e, cableId, vIndex) {
    if (cableTool.on) return;
    e.preventDefault();
    e.stopPropagation();
    root.focus();

    selectOnly([cableId]);
    const it = getItemById(cableId);
    if (!it || it.locked) return;

    const p0 = svgPointFromEvent(e);
    drag.active = true;
    drag.mode = "vertex";
    drag.pointerId = e.pointerId;
    drag.start = p0;
    drag.vertex = { id: cableId, index: vIndex };
    drag.originals = new Map([[cableId, deepClone(it)]]);

    els.svg.setPointerCapture(e.pointerId);
  }

  function onPointerMove(e) {
    if (dragSelect.active) {
      dragSelect.end = svgPointFromEvent(e);
      updateDragSelectRect();
      return;
    }
    if (!drag.active) return;

    const p = svgPointFromEvent(e);

    if (drag.mode === "vertex" && drag.vertex) {
      const it = getItemById(drag.vertex.id);
      const orig = drag.originals.get(drag.vertex.id);
      if (!it || !orig) return;

      const dx = p.x - drag.start.x;
      const dy = p.y - drag.start.y;
      let nx = orig.points[drag.vertex.index].x + dx;
      let ny = orig.points[drag.vertex.index].y + dy;

      const snapped = snapPoint({ x: nx, y: ny });
      it.points[drag.vertex.index] = snapped;
      draw();
      return;
    }

    if (drag.mode === "move") {
      const origPrimary = drag.originals.get(drag.primaryId);
      if (!origPrimary) return;

      let dx = p.x - drag.start.x;
      let dy = p.y - drag.start.y;

      // snap based on primary item
      if (els.snap.checked) {
        if (origPrimary.kind === "cable" && origPrimary.points && origPrimary.points.length) {
          const sp = snapPoint({ x: origPrimary.points[0].x + dx, y: origPrimary.points[0].y + dy });
          dx = sp.x - origPrimary.points[0].x;
          dy = sp.y - origPrimary.points[0].y;
        } else {
          const sp = snapPoint({ x: origPrimary.x + dx, y: origPrimary.y + dy });
          dx = sp.x - origPrimary.x;
          dy = sp.y - origPrimary.y;
        }
      }

      for (const xid of drag.ids) {
        const it = getItemById(xid);
        const orig = drag.originals.get(xid);
        if (!it || !orig) continue;

        if (it.kind === "cable") {
          it.points = orig.points.map(pt => ({
            x: clampf(pt.x + dx, 0, stage.w),
            y: clampf(pt.y + dy, 0, stage.h),
          }));
        } else {
          it.x = clampf(orig.x + dx, 0, stage.w);
          it.y = clampf(orig.y + dy, 0, stage.h);
        }
      }

      draw();
      return;
    }
  }

  function updateDragSelectRect() {
    if (!dragSelect.active || !dragSelect.start || !dragSelect.end) return;
    const x1 = dragSelect.start.x;
    const y1 = dragSelect.start.y;
    const x2 = dragSelect.end.x;
    const y2 = dragSelect.end.y;
    const minX = Math.min(x1, x2);
    const minY = Math.min(y1, y2);
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    els.selRect.setAttribute("x", minX);
    els.selRect.setAttribute("y", minY);
    els.selRect.setAttribute("width", w);
    els.selRect.setAttribute("height", h);
    els.selection.setAttribute("visibility", "visible");
  }

  function finishDragSelect(e) {
    if (!dragSelect.active || !dragSelect.start || !dragSelect.end) return;
    const x1 = dragSelect.start.x;
    const y1 = dragSelect.start.y;
    const x2 = dragSelect.end.x;
    const y2 = dragSelect.end.y;
    const minX = Math.min(x1, x2);
    const minY = Math.min(y1, y2);
    const maxX = Math.max(x1, x2);
    const maxY = Math.max(y1, y2);
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);

    dragSelect.active = false;
    dragSelect.start = null;
    dragSelect.end = null;

    // If the drag was tiny, treat as click-to-clear
    if (dx < 3 && dy < 3) {
      clearSelection();
      return;
    }

    const ids = [];
    for (const it of items) {
      if (it.locked) continue;
      const el = getRenderedEl(it.id);
      if (!el) continue;
      const bb = getTransformedBBox(el);
      if (!bb) continue;
      const intersects = !(bb.x > maxX || (bb.x + bb.width) < minX || bb.y > maxY || (bb.y + bb.height) < minY);
      if (intersects) ids.push(it.id);
    }
    if (e && e.shiftKey) {
      toggleSelectionIds(ids);
    } else {
      selectOnly(ids);
    }
  }

  function onPointerUp(e) {
    if (dragSelect.active) {
      finishDragSelect(e);
      try { els.svg.releasePointerCapture && els.svg.releasePointerCapture(e.pointerId); } catch (err) {}
      return;
    }
    if (!drag.active) return;
    drag.active = false;
    try { els.svg.releasePointerCapture(e.pointerId); } catch (_) {}

    // Push history after move/vertex drag
    pushHistory("drag");
    drag.mode = null;
    drag.pointerId = null;
    drag.start = null;
    drag.ids = [];
    drag.primaryId = null;
    drag.originals = null;
    drag.vertex = null;
  }

  // ============================================================
  // CABLE TOOL
  // ============================================================
  function toggleCableTool(on) {
    const next = !!on;
    if (cableTool.on === next) return;

    // If turning OFF and we have a draft, commit it (if valid)
    if (!next && cableTool.draft && cableTool.draft.points.length >= 2) {
      addCableFromDraft();
    } else if (!next) {
      cableTool.draft = null;
    }

    cableTool.on = next;
    if (els.cableModeBtn) {
      els.cableModeBtn.setAttribute("aria-pressed", cableTool.on ? "true" : "false");
      els.cableModeBtn.textContent = `Cable Tool: ${cableTool.on ? "On" : "Off"}`;
    }
    // Apply a visual cursor indicator while cable tool is active
    try { root.classList.toggle('sp-cable-mode', !!cableTool.on); } catch (err) {}
    draw();
  }

  function drawCableDraft() {
    els.cableDraft.innerHTML = "";
    if (!cableTool.draft) return;
    const pts = cableTool.draft.points.map(p => `${p.x},${p.y}`).join(" ");
    const g = svgEl("g");
    g.innerHTML = `
      <polyline points="${pts}" fill="none" stroke="${escapeAttr(cableTool.draft.color)}"
        stroke-width="${cableTool.draft.width}"
        stroke-linecap="round" stroke-linejoin="round"
        stroke-dasharray="6 6" opacity="0.85"/>
    `;
    els.cableDraft.appendChild(g);
    if (els.cableFinishBtn) els.cableFinishBtn.disabled = !(cableTool.on && cableTool.draft && cableTool.draft.points.length >= 2);
  }

  function addCablePointFromEvent(e) {
    const p = svgPointFromEvent(e);
    const pt = snapPoint(p);

    if (!cableTool.draft) {
      cableTool.draft = {
        points: [pt],
        color: els.cableColor ? els.cableColor.value : "#111111",
        width: clampf(parseFloat((els.cableWidth && els.cableWidth.value) || "3"), 1, 20),
      };
    } else {
      cableTool.draft.points.push(pt);
    }
    draw();
  }

  function finishCableDraft() {
    if (!cableTool.on) return;
    if (!cableTool.draft) return;
    if (cableTool.draft.points.length < 2) { cableTool.draft = null; draw(); return; }
    addCableFromDraft();
    draw();
  }

  function cancelCableDraft() {
    cableTool.draft = null;
    draw();
  }

  function popCableDraftPoint() {
    if (!cableTool.draft) return;
    cableTool.draft.points.pop();
    if (cableTool.draft.points.length === 0) cableTool.draft = null;
    draw();
  }

  // Capture pointerdown so cable tool works even over items
  els.svg.addEventListener("pointerdown", (e) => {
    if (!cableTool.on) return;
    e.preventDefault();
    e.stopPropagation();
    root.focus();
    addCablePointFromEvent(e);
  }, true);

  function snapPoint(p) {
    let x = clampf(p.x, 0, stage.w);
    let y = clampf(p.y, 0, stage.h);
    if (els.snap && els.snap.checked) {
      const gs = gridStepPx();
      x = Math.round(x / gs) * gs;
      y = Math.round(y / gs) * gs;
    }
    return { x, y };
  }

  // When not in cable tool, clicking blank stage clears selection
  function onStagePointerDown(e) {
    root.focus();

    // Cable tool: always place points, regardless of what's under the cursor
    if (cableTool.on) {
      e.preventDefault();
      const p = svgPointFromEvent(e);
      const pt = snapPoint(p);

      if (!cableTool.draft) {
        cableTool.draft = {
          points: [pt],
          color: els.cableColor.value,
          width: clampf(parseInt(els.cableWidth.value || "3", 10), 1, 12),
        };
      } else {
        cableTool.draft.points.push(pt);
      }
      draw();
      return;
    }

    const t = e.target;
    const hitItem = t && t.closest ? t.closest('[data-id]') : null;
    const isBlank = (!hitItem) && (t === els.svg || t.id === "sp-bg" || t.id === "sp-gridRect" || t.id === "sp-items" || t.id === "sp-guides" || t.id === "sp-overlay" || t.id === "sp-selection");
    if (!isBlank) return;
    e.preventDefault();

    // start drag-select
    dragSelect.active = true;
    dragSelect.start = svgPointFromEvent(e);
    dragSelect.end = dragSelect.start;
    els.selection.setAttribute("visibility", "visible");
    els.selRect.setAttribute("x", dragSelect.start.x);
    els.selRect.setAttribute("y", dragSelect.start.y);
    els.selRect.setAttribute("width", 0);
    els.selRect.setAttribute("height", 0);
    els.svg.setPointerCapture && els.svg.setPointerCapture(e.pointerId);
  }

  // ============================================================
  // TRANSFORMS / LAYERING / GROUPING
  // ============================================================
  function rotateSelected(delta) {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const list = ids.map(getItemById).filter(Boolean);
    if (list.some(it => it.locked)) return;
    for (const it of list) {
      if (it.kind === "cable") continue;
      it.r = mod((it.r || 0) + delta, 360);
    }
    pushHistory("rotate");
    draw();
  }

  function scaleSelected(factor) {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const list = ids.map(getItemById).filter(Boolean);
    if (list.some(it => it.locked)) return;
    for (const it of list) {
      if (it.kind === "cable") continue;
      if (it.isRiser || it.iconId === "riser") continue;
      const next = clampf((it.s || 1) * factor, 0.2, 8);
      it.s = next;
      // Keep icon scale axes in sync so renderIcon reflects changes
      if (it.kind === "icon") { it.sx = next; it.sy = next; }
    }
    pushHistory("scale");
    draw();
  }

  function setLockForIds(ids, locked) {
    for (const id of ids) {
      const it = getItemById(id);
      if (it) it.locked = !!locked;
    }
    updateInspector();
  }

  function toggleLockSelected() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const list = ids.map(getItemById).filter(Boolean);
    const allLocked = list.every(it => it.locked);
    setLockForIds(ids, !allLocked);
    pushHistory("lock");
    draw();
  }

  function deleteIds(ids) {
    const set = new Set(ids);
    items = items.filter(it => !set.has(it.id));
    // cleanup groups with no members
    cleanupGroups();
    // update selection
    for (const id of ids) selected.delete(id);
    if (selected.size === 0) primaryId = null;
    updateInspector();
  }

  function deleteSelected() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    deleteIds(ids);
    pushHistory("delete");
    draw();
  }

  function cleanupGroups() {
    const live = new Set(items.map(it => it.groupId).filter(Boolean));
    for (const gid of Object.keys(groups)) {
      if (!live.has(gid)) delete groups[gid];
    }
  }

  function bringForward() {
    moveOneForward(getSelectedIds());
    pushHistory("bring forward");
    draw();
  }

  function sendBackward() {
    moveOneBackward(getSelectedIds());
    pushHistory("send back");
    draw();
  }

  function bringToFront() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const set = new Set(ids);
    const sel = items.filter(it => set.has(it.id));
    const rest = items.filter(it => !set.has(it.id));
    items = rest.concat(sel);
    pushHistory("bring front");
    draw();
  }

  function sendToBack() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const set = new Set(ids);
    const sel = items.filter(it => set.has(it.id));
    const rest = items.filter(it => !set.has(it.id));
    items = sel.concat(rest);
    pushHistory("send back all");
    draw();
  }

  function moveOneForward(ids) {
    const set = new Set(ids);
    for (let i = items.length - 2; i >= 0; i--) {
      if (set.has(items[i].id) && !set.has(items[i + 1].id)) {
        const tmp = items[i];
        items[i] = items[i + 1];
        items[i + 1] = tmp;
      }
    }
  }

  function moveOneBackward(ids) {
    const set = new Set(ids);
    for (let i = 1; i < items.length; i++) {
      if (set.has(items[i].id) && !set.has(items[i - 1].id)) {
        const tmp = items[i];
        items[i] = items[i - 1];
        items[i - 1] = tmp;
      }
    }
  }

  function moveBlockForward(start, end) {
    // start..end are indices in items array (back->front). Move block one step forward (toward front / higher index).
    if (end >= items.length - 1) return;
    const after = items[end + 1];
    items.splice(end + 1, 1);
    items.splice(start, 0, after);
  }

  function moveBlockBackward(start, end) {
    if (start <= 0) return;
    const before = items[start - 1];
    items.splice(start - 1, 1);
    items.splice(end, 0, before);
  }

  // Group / Ungroup
  function groupSelected() {
    const ids = getSelectedIds();
    if (ids.length < 2) return;

    const selSet = new Set(ids);
    const indices = items.map((it, idx) => selSet.has(it.id) ? idx : -1).filter(i => i >= 0);
    const maxIndex = Math.max(...indices);
    const removedBefore = indices.filter(i => i < maxIndex).length;
    const insertIndex = maxIndex - removedBefore;

    const selectedItems = items.filter(it => selSet.has(it.id));
    const rest = items.filter(it => !selSet.has(it.id));

    const gid = "g_" + Math.random().toString(16).slice(2);
    groups[gid] = { name: `Group ${groupCounter++}` };

    for (const it of selectedItems) it.groupId = gid;

    // Insert as contiguous block
    items = rest.slice(0, insertIndex).concat(selectedItems).concat(rest.slice(insertIndex));

    selectOnly(selectedItems.map(it => it.id));
    pushHistory("group");
    draw();
  }

  function ungroupSelected() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    const selItems = ids.map(getItemById).filter(Boolean);
    const gids = new Set(selItems.map(it => it.groupId).filter(Boolean));
    if (gids.size === 0) return;

    for (const gid of gids) {
      for (const it of items) {
        if (it.groupId === gid) it.groupId = null;
      }
      delete groups[gid];
      delete ui.groupCollapsed[gid];
    }
    cleanupGroups();
    pushHistory("ungroup");
    draw();
  }

  // Duplicate
  function duplicateIds(ids, preserveGroup = false) {
    if (!ids.length) return;
    const selSet = new Set(ids);
    const inOrder = items.filter(it => selSet.has(it.id));
    const indices = items.map((it, idx) => selSet.has(it.id) ? idx : -1).filter(i => i >= 0);
    const maxIndex = Math.max(...indices);

    const offset = 24;

    // map group ids -> new group ids
    const oldGids = new Set(inOrder.map(it => it.groupId).filter(Boolean));
    const gidMap = {};
    for (const og of oldGids) {
      const ng = "g_" + Math.random().toString(16).slice(2);
      gidMap[og] = preserveGroup ? ng : null;
      if (preserveGroup) {
        const name = groups[og]?.name || "Group";
        groups[ng] = { name: name + " copy" };
      }
    }

    const clones = inOrder.map((it) => {
      const c = deepClone(it);
      c.id = uid();
      c.locked = false;
      if (c.kind === "cable") {
        c.points = c.points.map(p => ({ x: clampf(p.x + offset, 0, stage.w), y: clampf(p.y + offset, 0, stage.h) }));
      } else {
        c.x = clampf(c.x + offset, 0, stage.w);
        c.y = clampf(c.y + offset, 0, stage.h);
      }
      if (c.groupId && preserveGroup) c.groupId = gidMap[c.groupId] || null;
      else c.groupId = null; // duplicates start ungrouped unless duplicating a group
      return c;
    });

    items.splice(maxIndex + 1, 0, ...clones);

    selectOnly(clones.map(c => c.id));
    pushHistory("duplicate");
    draw();
  }

  function duplicateSelected() {
    const ids = getSelectedIds();
    if (!ids.length) return;
    // If selection is exactly a group: preserve group
    const selItems = ids.map(getItemById).filter(Boolean);
    const gid = selItems[0]?.groupId;
    const sameGroup = gid && selItems.every(it => it.groupId === gid);
    duplicateIds(ids, !!sameGroup);
  }

  // ============================================================
  // SAVE / LOAD / EXPORT
  // ============================================================
  function downloadJson() {
    const data = {
      version: 2,
      units: els.units ? els.units.value : "ft",
      stage: {
        w: stage.w,
        h: stage.h,
        grid: stage.showGrid,
        gridSizeUnits: parseFloat(els.gridSize.value || "1"),
        snap: !!(els.snap && els.snap.checked),
        zoom: stage.zoom,
      },
      groups,
      items,
    };
    downloadBlob(new Blob([JSON.stringify(data, null, 2)], { type: "application/json" }), "stageplot.json");
  }

  function loadJsonFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (!data || !data.stage || !Array.isArray(data.items)) throw new Error("Invalid file.");
        history.suspend = true;

        if (els.units && (data.units === "m" || data.units === "ft")) els.units.value = data.units;

        stage.showGrid = !!data.stage.grid;
        stage.zoom = clampf(num(data.stage.zoom, 1), 0.6, 2.0);

        if (els.gridSize) els.gridSize.value = String(num(data.stage.gridSizeUnits, 1));
        if (els.snap) els.snap.checked = !!data.stage.snap;

        if (els.gridBtn) {
          els.gridBtn.textContent = `Grid: ${stage.showGrid ? "On" : "Off"}`;
          els.gridBtn.setAttribute("aria-pressed", stage.showGrid ? "true" : "false");
        }

        groups = data.groups && typeof data.groups === "object" ? data.groups : {};
        groupCounter = 1 + Object.keys(groups).length;

        items = data.items.map(it => normalizeItem({ ...it, id: it.id || uid() }));
        setStageSizePx(num(data.stage.w, 1200), num(data.stage.h, 700));

        // update W/H input display to current units
        if (els.w) els.w.value = String(round2(pxToUnits(stage.w)));
        if (els.h) els.h.value = String(round2(pxToUnits(stage.h)));

        clearSelection();
        toggleCableTool(false);

        // reset history
        history.stack = [];
        history.index = -1;
        pushHistory("load", true);

        history.suspend = false;
        draw();
      } catch (err) {
        history.suspend = false;
        alert("Could not load JSON: " + err.message);
      }
    };
    reader.readAsText(file);
  }

  function exportSvg() {
    const clone = els.svg.cloneNode(true);
    clone.removeAttribute("class");
    clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    clone.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    const overlay = clone.querySelector("#sp-overlay");
    if (overlay) overlay.remove();
    const svgText = `<?xml version="1.0" encoding="UTF-8"?>\n` + clone.outerHTML;
    downloadBlob(new Blob([svgText], { type:"image/svg+xml" }), "stageplot.svg");
  }

  async function exportPng() {
    try {
      const clone = els.svg.cloneNode(true);
      const overlay = clone.querySelector("#sp-overlay");
      if (overlay) overlay.remove();
      clone.setAttribute("xmlns", "http://www.w3.org/2000/svg");

      const svgText = clone.outerHTML;
      const svgDataUrl = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svgText);

      const img = new Image();
      img.crossOrigin = "anonymous";
      await new Promise((res, rej) => {
        img.onload = res;
        img.onerror = () => rej(new Error("PNG export failed (image/CORS issue). Export SVG instead."));
        img.src = svgDataUrl;
      });

      const canvas = document.createElement("canvas");
      canvas.width = stage.w;
      canvas.height = stage.h;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(img, 0, 0);

      canvas.toBlob((blob) => {
        if (!blob) throw new Error("PNG export failed.");
        downloadBlob(blob, "stageplot.png");
      }, "image/png");
    } catch (err) {
      alert(err.message);
    }
  }

  // ============================================================
  // HISTORY (Undo/Redo)
  // ============================================================
  function snapshotState() {
    return {
      stage: { ...stage },
      units: els.units ? els.units.value : "ft",
      gridSizeUnits: parseFloat(els.gridSize.value || "1"),
      snap: !!(els.snap && els.snap.checked),
      groups: deepClone(groups),
      items: deepClone(items),
      selected: getSelectedIds(),
    };
  }

  function restoreState(st) {
    history.suspend = true;
    stage = { ...st.stage };
    if (els.units && (st.units === "m" || st.units === "ft")) els.units.value = st.units;
    if (els.gridSize) els.gridSize.value = String(st.gridSizeUnits ?? 1);
    if (els.snap) els.snap.checked = !!st.snap;
    groups = st.groups || {};
    items = (st.items || []).map(normalizeItem);

    // update W/H input to current units
    if (els.w) els.w.value = String(round2(pxToUnits(stage.w)));
    if (els.h) els.h.value = String(round2(pxToUnits(stage.h)));

    if (els.gridBtn) {
      els.gridBtn.textContent = `Grid: ${stage.showGrid ? "On" : "Off"}`;
      els.gridBtn.setAttribute("aria-pressed", stage.showGrid ? "true" : "false");
    }

    selected = new Set(st.selected || []);
    primaryId = (st.selected && st.selected.length) ? st.selected[0] : null;

    updateInspector();
    history.suspend = false;
    draw();
  }

  function pushHistory(reason, force = false) {
    if (history.suspend) return;
    const st = snapshotState();
    const json = JSON.stringify(st);
    if (!force && history.index >= 0 && history.stack[history.index] === json) return;

    // drop redo
    history.stack = history.stack.slice(0, history.index + 1);
    history.stack.push(json);
    history.index = history.stack.length - 1;

    // limit
    if (history.stack.length > 100) {
      history.stack.shift();
      history.index--;
    }
    updateUndoRedoButtons();
  }

  function debounceHistory(reason) {
    if (history.suspend) return;
    if (history.debounceTimer) clearTimeout(history.debounceTimer);
    history.debounceTimer = setTimeout(() => {
      pushHistory(reason);
      history.debounceTimer = null;
    }, 450);
  }

  function undo() {
    if (history.index <= 0) return;
    history.index--;
    const st = JSON.parse(history.stack[history.index]);
    restoreState(st);
    updateUndoRedoButtons();
  }

  function redo() {
    if (history.index >= history.stack.length - 1) return;
    history.index++;
    const st = JSON.parse(history.stack[history.index]);
    restoreState(st);
    updateUndoRedoButtons();
  }

  function updateUndoRedoButtons() {
    if (els.undoBtn) els.undoBtn.disabled = history.index <= 0;
    if (els.redoBtn) els.redoBtn.disabled = history.index >= history.stack.length - 1;
  }

  // ============================================================
  // EVENTS
  // ============================================================
  els.svg.addEventListener("pointermove", onPointerMove);
  els.svg.addEventListener("pointerup", onPointerUp);
  els.svg.addEventListener("pointercancel", onPointerUp);
  els.svg.addEventListener("pointerdown", onStagePointerDown);
  els.svg.addEventListener("dblclick", (e) => {
    if (!cableTool.on || !cableTool.draft) return;

    // Dedupe last point if double-click added a duplicate snapped point
    const pts = cableTool.draft.points;
    if (pts.length >= 2) {
      const a = pts[pts.length - 1];
      const b = pts[pts.length - 2];
      if (a.x === b.x && a.y === b.y) pts.pop();
    }

    finishCableDraft();
    e.preventDefault();
  });

  // Drag & drop from library / external files
  els.svg.addEventListener("dragover", (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = "copy";
  });

  els.svg.addEventListener("drop", (e) => {
    e.preventDefault();
    root.focus();

    const p = svgPointFromClient(e.clientX, e.clientY);

    // 1) If dropping an image file, add as image at drop point
    const files = e.dataTransfer.files;
    if (files && files.length) {
      const f = files[0];
      if (f.type && f.type.startsWith("image/")) {
        const reader = new FileReader();
        reader.onload = () => addImageItemAt(reader.result, f.name, p.x, p.y);
        reader.readAsDataURL(f);
        return;
      }
    }

    // 2) Otherwise, treat as icon drop
    const iconId =
      e.dataTransfer.getData("application/x-stageplot-icon") ||
      e.dataTransfer.getData("text/plain");

    const icon = LIB_ITEMS.find(x => x.id === iconId);
    if (icon) addIconItemAt(icon, p.x, p.y);
  });

  if (els.gridBtn) {
    els.gridBtn.addEventListener("click", () => {
      stage.showGrid = !stage.showGrid;
      els.gridBtn.textContent = `Grid: ${stage.showGrid ? "On" : "Off"}`;
      els.gridBtn.setAttribute("aria-pressed", stage.showGrid ? "true" : "false");
      pushHistory("toggle grid");
      draw();
    });
  }

  if (els.search) els.search.addEventListener("input", () => renderLibrary(els.search.value));

  if (els.resizeBtn) els.resizeBtn.addEventListener("click", setStageFromInputs);

  if (els.saveBtn) els.saveBtn.addEventListener("click", downloadJson);
  if (els.loadInput) els.loadInput.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) loadJsonFile(f);
    e.target.value = "";
  });

  if (els.exportSvgBtn) els.exportSvgBtn.addEventListener("click", exportSvg);
  if (els.exportPngBtn) els.exportPngBtn.addEventListener("click", exportPng);

  if (els.addTextBtn) els.addTextBtn.addEventListener("click", () => { addTextItem(); root.focus(); });

  if (els.addImageInput) els.addImageInput.addEventListener("change", (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = () => addImageItem(reader.result, f.name);
    reader.readAsDataURL(f);
    e.target.value = "";
    root.focus();
  });

  if (els.cableModeBtn) els.cableModeBtn.addEventListener("click", () => toggleCableTool(!cableTool.on));
  if (els.cableFinishBtn) els.cableFinishBtn.addEventListener("click", () => { finishCableDraft(); root.focus(); });

  if (els.clearSel) els.clearSel.addEventListener("click", clearSelection);
  if (els.deleteBtn) els.deleteBtn.addEventListener("click", deleteSelected);
  if (els.lockBtn) els.lockBtn.addEventListener("click", toggleLockSelected);
  if (els.bringFwd) els.bringFwd.addEventListener("click", bringForward);
  if (els.sendBack) els.sendBack.addEventListener("click", sendBackward);
  if (els.bringFront) els.bringFront.addEventListener("click", bringToFront);
  if (els.sendBackAll) els.sendBackAll.addEventListener("click", sendToBack);
  if (els.duplicateBtn) els.duplicateBtn.addEventListener("click", duplicateSelected);
  if (els.groupBtn) els.groupBtn.addEventListener("click", groupSelected);
  if (els.ungroupBtn) els.ungroupBtn.addEventListener("click", ungroupSelected);

  if (els.undoBtn) els.undoBtn.addEventListener("click", undo);
  if (els.redoBtn) els.redoBtn.addEventListener("click", redo);

  if (els.zoomIn) els.zoomIn.addEventListener("click", () => { stage.zoom = clampf(stage.zoom + 0.1, 0.6, 2.0); pushHistory("zoom"); applyZoom(); });
  if (els.zoomOut) els.zoomOut.addEventListener("click", () => { stage.zoom = clampf(stage.zoom - 0.1, 0.6, 2.0); pushHistory("zoom"); applyZoom(); });

  // Quick-adjust nudge helpers (scale / font / W/H)
  function nudgeScale(mult) {
    const ids = getSelectedIds(); if (ids.length !== 1) return;
    const it = getItemById(ids[0]); if (!it || it.locked) return;
    if (it.kind === "cable") return;
    const next = clampf((it.s || 1) * mult, 0.2, 8);
    it.s = next;
    if (it.kind === "icon") { it.sx = next; it.sy = next; }
    draw();
    pushHistory("nudge scale");
  }

  function nudgeFont(delta) {
    const ids = getSelectedIds(); if (ids.length !== 1) return;
    const it = getItemById(ids[0]); if (!it || it.locked) return;
    if (it.kind !== "text") return;
    it.fontSize = clampf((it.fontSize || 24) + delta, 8, 160);
    draw();
    pushHistory("nudge font");
  }

  function nudgeWH(deltaW, deltaH) {
    const ids = getSelectedIds(); if (ids.length !== 1) return;
    const it = getItemById(ids[0]); if (!it || it.locked) return;

    if (it.kind === "image") {
      it.iw = clampf((it.iw || 220) + deltaW, 30, 4000);
      it.ih = clampf((it.ih || 220) + deltaH, 30, 4000);
      it.bw = (it.iw || 220) + 40;
      it.bh = (it.ih || 220) + 40;
      draw();
      pushHistory("nudge image size");
      return;
    }

    if (it.kind === "shape") {
      it.w = clampf((it.w || 120) + deltaW, 10, 4000);
      it.h = clampf((it.h || 120) + deltaH, 10, 4000);
      it.bw = (it.w || 120) + 40;
      it.bh = (it.h || 120) + 40;
      draw();
      pushHistory("nudge shape size");
      return;
    }
  }

  function attachQuickAdjust() {
    const sDown = document.getElementById("sp-qaScaleDown");
    const sUp = document.getElementById("sp-qaScaleUp");
    const fDown = document.getElementById("sp-qaFontDown");
    const fUp = document.getElementById("sp-qaFontUp");
    const wDown = document.getElementById("sp-qaWDown");
    const wUp = document.getElementById("sp-qaWUp");
    const hDown = document.getElementById("sp-qaHDown");
    const hUp = document.getElementById("sp-qaHUp");

    if (sDown) sDown.addEventListener("click", () => nudgeScale(1 / 1.05));
    if (sUp) sUp.addEventListener("click", () => nudgeScale(1.05));
    if (fDown) fDown.addEventListener("click", () => nudgeFont(-2));
    if (fUp) fUp.addEventListener("click", () => nudgeFont(+2));
    if (wDown) wDown.addEventListener("click", () => {
      const ids = getSelectedIds(); if (ids.length !== 1) return; const it = getItemById(ids[0]); if (!it || it.locked) return;
      if (it.isRiser || it.iconId === 'riser') {
        const cur = round2(pxToUnits(it.w || 0)); const nu = Math.max(0.1, cur - 1);
        it.w = unitsToPx(nu); draw(); pushHistory('nudge riser size');
      } else nudgeWH(-10, 0);
    });
    if (wUp) wUp.addEventListener("click", () => {
      const ids = getSelectedIds(); if (ids.length !== 1) return; const it = getItemById(ids[0]); if (!it || it.locked) return;
      if (it.isRiser || it.iconId === 'riser') {
        const cur = round2(pxToUnits(it.w || 0)); const nu = cur + 1;
        it.w = unitsToPx(nu); draw(); pushHistory('nudge riser size');
      } else nudgeWH(+10, 0);
    });
    if (hDown) hDown.addEventListener("click", () => {
      const ids = getSelectedIds(); if (ids.length !== 1) return; const it = getItemById(ids[0]); if (!it || it.locked) return;
      if (it.isRiser || it.iconId === 'riser') {
        const cur = round2(pxToUnits(it.h || 0)); const nu = Math.max(0.1, cur - 1);
        it.h = unitsToPx(nu); draw(); pushHistory('nudge riser size');
      } else nudgeWH(0, -10);
    });
    if (hUp) hUp.addEventListener("click", () => {
      const ids = getSelectedIds(); if (ids.length !== 1) return; const it = getItemById(ids[0]); if (!it || it.locked) return;
      if (it.isRiser || it.iconId === 'riser') {
        const cur = round2(pxToUnits(it.h || 0)); const nu = cur + 1;
        it.h = unitsToPx(nu); draw(); pushHistory('nudge riser size');
      } else nudgeWH(0, +10);
    });
  }

  if (els.units) {
    els.units.addEventListener("change", () => {
      // keep stage px size the same; only update displayed units and grid
      if (els.w) els.w.value = String(round2(pxToUnits(stage.w)));
      if (els.h) els.h.value = String(round2(pxToUnits(stage.h)));
      pushHistory("units");
      draw();
      updateInspector();
    });
  }

  // Library collapse
  if (els.libToggle) {
    els.libToggle.addEventListener("click", () => {
      const collapsed = root.classList.toggle("sp-lib-collapsed");
      els.libToggle.setAttribute("aria-pressed", collapsed ? "true" : "false");
      const lbl = els.libToggle.querySelector('.sp-libToggleLabel');
      if (lbl) lbl.textContent = collapsed ? "Show" : "Hide";
      const collLabel = document.querySelector('.sp-collapsedLabel');
      if (collLabel) collLabel.style.display = collapsed ? 'inline-block' : 'none';
      try { localStorage.setItem("sp.lib.collapsed", collapsed ? "1" : "0"); } catch (err) {}
    });
  }

  // Fullscreen toggle
  if (els.fullscreenBtn) {
    const fb = els.fullscreenBtn;
    function updateFullBtn() { fb.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Fullscreen'; }
    fb.addEventListener('click', async () => {
      try {
        if (!document.fullscreenElement) await root.requestFullscreen();
        else await document.exitFullscreen();
      } catch (err) { /* ignore */ }
    });
    document.addEventListener('fullscreenchange', () => {
      updateFullBtn();
      try { 
        const isRoot = document.fullscreenElement === root;
        root.classList.toggle('sp-fullscreen', isRoot); 
        // show fullscreen toggles only in fullscreen
        if (els.fullLibToggle) els.fullLibToggle.style.display = isRoot ? 'inline-block' : 'none';
        if (els.fullInspectorToggle) els.fullInspectorToggle.style.display = isRoot ? 'inline-block' : 'none';

        const sp = document.querySelector('.sp-sidepanel');
        const lib = document.querySelector('.sp-library');

        if (isRoot) {
          // show floating inspector by default
          root.classList.add('sp-full-inspector-visible');
          if (sp) sp.classList.add('floating');
          // hide floating library by default when entering fullscreen to maximize canvas
          root.classList.remove('sp-full-lib-visible');
        } else {
          // reset fullscreen-only classes and inline styles
          root.classList.remove('sp-full-inspector-visible');
          if (sp) {
            sp.classList.remove('floating', 'minimized', 'dragging');
            sp.style.position = '';
            sp.style.left = '';
            sp.style.top = '';
            sp.style.right = '';
            sp.style.width = '';
            sp.style.maxHeight = '';
          }
          if (lib) {
            lib.classList.remove('dragging');
            lib.style.position = '';
            lib.style.left = '';
            lib.style.top = '';
            lib.style.right = '';
            lib.style.width = '';
            lib.style.maxHeight = '';
          }
        }
      } catch (err) {}
      try { adjustFullscreenCanvas(); } catch (err) {}
    });
    updateFullBtn();
  }

  // Fullscreen library toggle
  if (els.fullLibToggle) {
    els.fullLibToggle.addEventListener('click', () => {
      try { root.classList.toggle('sp-full-lib-visible'); adjustFullscreenCanvas(); } catch (err) {}
    });
  }

  // Fullscreen inspector toggle
  if (els.fullInspectorToggle) {
    els.fullInspectorToggle.addEventListener('click', () => {
      try {
        // toggle root class and apply floating class to sidepanel
        root.classList.toggle('sp-full-inspector-visible');
        const sp = document.querySelector('.sp-sidepanel');
        if (sp) {
          if (root.classList.contains('sp-full-inspector-visible')) sp.classList.add('floating');
          else sp.classList.remove('floating');
        }
        adjustFullscreenCanvas();
      } catch (err) {}
    });
  }

  // Make the floating inspector draggable and add minimize control
  (function initFloatingInspector(){
    const sp = document.querySelector('.sp-sidepanel');
    if (!sp) return;
    // add floating header if not present
    let hdr = sp.querySelector('.sp-float-hdr');
    if (!hdr) {
      hdr = document.createElement('div');
      hdr.className = 'sp-float-hdr';
      hdr.innerHTML = `<div class="sp-title">Inspector</div><button class="sp-float-btn" id="sp-inspectorMin">—</button>`;
      sp.insertBefore(hdr, sp.firstChild);
    }

    const minBtn = hdr.querySelector('#sp-inspectorMin');
    minBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      sp.classList.toggle('minimized');
      try { localStorage.setItem('sp.inspector.minimized', sp.classList.contains('minimized') ? '1' : '0'); } catch (err) {}
    });

    let drag = { active:false, startX:0, startY:0, origLeft:0, origTop:0 };
    function toNumber(px){ return Number(String(px||'').replace('px','')) || 0; }

    hdr.addEventListener('pointerdown', (e) => {
      if (!(root.classList && root.classList.contains('sp-fullscreen'))) return;
      if (!sp.classList.contains('floating')) return;
      drag.active = true;
      drag.startX = e.clientX;
      drag.startY = e.clientY;
      sp.style.position = 'fixed';
      // initialize left/top from current rect so we have stable drag math
      const rect = sp.getBoundingClientRect();
      sp.style.left = (sp.style.left || rect.left + 'px');
      sp.style.top = (sp.style.top || rect.top + 'px');
      sp.style.right = 'auto';
      drag.origLeft = toNumber(sp.style.left);
      drag.origTop = toNumber(sp.style.top);
      sp.classList.add('dragging');
      hdr.setPointerCapture && hdr.setPointerCapture(e.pointerId);
    });

    window.addEventListener('pointermove', (e) => {
      if (!drag.active) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      let left = Math.round(drag.origLeft + dx);
      let top = Math.round(drag.origTop + dy);
      const rect = sp.getBoundingClientRect();
      // clamp to viewport
      left = Math.max(8, Math.min(left, window.innerWidth - rect.width - 8));
      top = Math.max(8, Math.min(top, window.innerHeight - rect.height - 8));
      sp.style.left = left + 'px';
      sp.style.top = top + 'px';
      sp.style.right = 'auto';
    });

    window.addEventListener('pointerup', (e) => {
      if (!drag.active) return;
      drag.active = false;
      try { hdr.releasePointerCapture && hdr.releasePointerCapture(e.pointerId); } catch (err) {}
      sp.classList.remove('dragging');
      try { localStorage.setItem('sp.inspector.pos', JSON.stringify({ left: sp.style.left, top: sp.style.top })); } catch (err) {}
    });

    // restore saved state
    try {
      const pos = JSON.parse(localStorage.getItem('sp.inspector.pos') || 'null');
      if (pos && pos.left) { sp.style.left = pos.left; sp.style.top = pos.top; sp.style.right = 'auto'; }
      const min = localStorage.getItem('sp.inspector.minimized');
      if (min === '1') sp.classList.add('minimized');
    } catch (err) {}
  })();

  // Make the floating library draggable in fullscreen
  (function initFloatingLibraryDrag(){
    const lib = document.querySelector('.sp-library');
    if (!lib) return;
    const handle = lib.querySelector('.sp-libhead') || lib;
    let drag = { active:false, startX:0, startY:0, origLeft:0, origTop:0 };

    function toNumber(px){ return Number(String(px||'').replace('px','')) || 0; }

    handle.addEventListener('pointerdown', (e) => {
      // only allow dragging when in fullscreen
      if (!(root.classList && root.classList.contains('sp-fullscreen'))) return;
      drag.active = true;
      drag.startX = e.clientX;
      drag.startY = e.clientY;
      // ensure lib is fixed positioned
      lib.style.position = 'fixed';
      lib.style.left = lib.style.left || (lib.getBoundingClientRect().left + 'px');
      lib.style.top = lib.style.top || (lib.getBoundingClientRect().top + 'px');
      drag.origLeft = toNumber(lib.style.left);
      drag.origTop = toNumber(lib.style.top);
      lib.classList.add('dragging');
      handle.setPointerCapture(e.pointerId);
    });

    window.addEventListener('pointermove', (e) => {
      if (!drag.active) return;
      const dx = e.clientX - drag.startX;
      const dy = e.clientY - drag.startY;
      let nx = Math.round(drag.origLeft + dx);
      let ny = Math.round(drag.origTop + dy);
      // clamp to viewport
      nx = Math.max(8, Math.min(nx, window.innerWidth - lib.offsetWidth - 8));
      ny = Math.max(8, Math.min(ny, window.innerHeight - lib.offsetHeight - 8));
      lib.style.left = nx + 'px';
      lib.style.top = ny + 'px';
    });

    window.addEventListener('pointerup', (e) => {
      if (!drag.active) return;
      drag.active = false;
      try { handle.releasePointerCapture && handle.releasePointerCapture(e.pointerId); } catch (err) {}
      lib.classList.remove('dragging');
      // persist position so we can restore it next time
      try { localStorage.setItem('sp.lib.pos', JSON.stringify({ left: lib.style.left, top: lib.style.top })); } catch (err) {}
    });

    // restore position on load/enter fullscreen
    try {
      const pos = JSON.parse(localStorage.getItem('sp.lib.pos') || 'null');
      if (pos && pos.left) {
        lib.style.left = pos.left; lib.style.top = pos.top;
      }
    } catch (err) {}
  })();

  // Adjust SVG size in fullscreen to best-fit the available viewport while preserving aspect ratio
  function adjustFullscreenCanvas() {
    if (!els.svg) return;
    const isFull = document.fullscreenElement === root || root.classList.contains('sp-fullscreen');
    if (!isFull) { applyZoom(); return; }
    // Determine available space: account for floating library if visible
    const lib = document.querySelector('.sp-library');
    let reservedLeft = 40; // base padding
    if (lib && getComputedStyle(lib).display !== 'none') {
      reservedLeft = (lib.offsetWidth || 220) + 40;
    }
    const toolbar = document.querySelector('.sp-toolbar');
    const reservedTop = (toolbar ? (toolbar.offsetHeight || 56) : 56) + 16;
    const availW = Math.max(100, window.innerWidth - reservedLeft - 40);
    const availH = Math.max(100, window.innerHeight - reservedTop - 40);
    const stageRatio = (stage.w || 1) / (stage.h || 1);
    let drawW = availW;
    let drawH = Math.round(drawW / stageRatio);
    if (drawH > availH) {
      drawH = availH;
      drawW = Math.round(drawH * stageRatio);
    }
    // Debug: log computed sizes to help diagnose cropping on different screens
    try { console.debug('FS avail', availW, availH, 'stage', stage.w, stage.h, 'draw', drawW, drawH); } catch (err) {}
    // Emergency fallback: if computed draw area is much smaller than available,
    // force-fit to use available width (common on narrow viewports)
    if (drawW < availW * 0.6 && drawH < availH * 0.6) {
      drawW = availW;
      drawH = Math.round(drawW / stageRatio);
      if (drawH > availH) {
        drawH = availH;
        drawW = Math.round(drawH * stageRatio);
      }
      try { console.debug('FS fallback draw', drawW, drawH); } catch (err) {}
    }
    // Apply sizing and ensure CSS max constraints don't countermand us
    els.svg.style.width = drawW + 'px';
    els.svg.style.height = drawH + 'px';
  }

  window.addEventListener('resize', () => { try { adjustFullscreenCanvas(); } catch (err) {} });

  // Restore library collapsed state and height from localStorage
  try {
    const savedCollapsed = localStorage.getItem("sp.lib.collapsed");
    if (savedCollapsed === "1") root.classList.add("sp-lib-collapsed");
    const savedH = localStorage.getItem("sp.lib.height");
    if (savedH) root.style.setProperty("--sp-lib-height", savedH + "px");
    const lbl = document.getElementById('sp-libToggle') && document.getElementById('sp-libToggle').querySelector('.sp-libToggleLabel');
    if (lbl) lbl.textContent = root.classList.contains('sp-lib-collapsed') ? 'Show' : 'Hide';
  } catch (err) {}

  // Library resizer drag handling
  const libResizer = document.getElementById("sp-libResizer");
  const libEl = document.querySelector('.sp-library');
  if (libResizer && libEl) {
    let dragging = false;
    let startY = 0;
    let startH = 0;
    const onMove = (ev) => {
      const y = ev.clientY;
      let newH = startH + (y - startY);
      // enforce min/max so canvas never gets squished below minCanvas
      const bodyEl = document.querySelector('.sp-body');
      const bodyRect = bodyEl ? bodyEl.getBoundingClientRect() : { height: window.innerHeight - 200 };
      const minCanvas = parseInt(getComputedStyle(root).getPropertyValue('--sp-canvas-min-height')) || 420;
      const maxLib = Math.max(80, bodyRect.height - minCanvas);
      newH = Math.max(56, Math.min(newH, maxLib));
      root.style.setProperty('--sp-lib-height', newH + 'px');
    };
    const onUp = (ev) => {
      if (!dragging) return;
      dragging = false;
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      // persist
      try { const cur = getComputedStyle(libEl).height.replace('px',''); localStorage.setItem('sp.lib.height', Math.round(parseFloat(cur))); } catch (err) {}
    };
    libResizer.addEventListener('mousedown', (ev) => {
      ev.preventDefault();
      dragging = true;
      startY = ev.clientY;
      startH = parseFloat(getComputedStyle(libEl).height);
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // keep svg sizing responsive to viewport/container changes
  window.addEventListener('resize', () => { requestAnimationFrame(draw); });

  // Hotkeys (disabled while typing)
  root.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "input" || tag === "textarea" || tag === "select" || (e.target && e.target.isContentEditable)) return;

    const key = (e.key || "").toLowerCase();

    // Undo/redo
    const isMod = e.ctrlKey || e.metaKey;
    if (isMod && key === "z") {
      e.preventDefault();
      if (e.shiftKey) redo();
      else undo();
      return;
    }
    if (isMod && key === "y") { e.preventDefault(); redo(); return; }

    // Cable tool toggle
    if (key === "c") { e.preventDefault(); toggleCableTool(!cableTool.on); return; }

    // Cable tool actions
    if (cableTool.on) {
      if (e.key === "Enter") { e.preventDefault(); finishCableDraft(); return; }
      if (e.key === "Escape") { e.preventDefault(); cancelCableDraft(); return; }
      if (e.key === "Backspace" || e.key === "Delete") { e.preventDefault(); popCableDraftPoint(); return; }
    }

    // If no selection, stop here (except group keys, etc.)
    const ids = getSelectedIds();
    if (!ids.length) return;

    if (key === "delete" || key === "backspace") { e.preventDefault(); deleteSelected(); return; }

    if (key === "r") { e.preventDefault(); rotateSelected(e.shiftKey ? -5 : 5); return; } // fixed: shift works
    if (e.key === "+" || (e.key === "=" && e.shiftKey)) {
      e.preventDefault();
      scaleSelected(1.08);
      return;
    }
    if (e.key === "-") {
      e.preventDefault();
      scaleSelected(1/1.08);
      return;
    }

    // Bring forward/back hotkeys removed (use Layers panel)

    if (key === "l") { e.preventDefault(); toggleLockSelected(); return; }
    if (key === "d") { e.preventDefault(); duplicateSelected(); return; }
    if (key === "g") {
      e.preventDefault();
      if (e.shiftKey) ungroupSelected();
      else groupSelected();
      return;
    }
  });

  // ============================================================
  // HELPERS
  // ============================================================
  function svgPointFromEvent(evt) {
    const pt = els.svg.createSVGPoint();
    pt.x = evt.clientX;
    pt.y = evt.clientY;
    const ctm = els.svg.getScreenCTM();
    if (!ctm) return { x: 0, y: 0 };
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  function svgPointFromClient(clientX, clientY) {
    const pt = els.svg.createSVGPoint();
    pt.x = clientX;
    pt.y = clientY;
    const ctm = els.svg.getScreenCTM();
    if (!ctm) return { x: 0, y: 0 };
    const p = pt.matrixTransform(ctm.inverse());
    return { x: p.x, y: p.y };
  }

  function fmt1(n){ return (Math.round(n * 10) / 10).toString(); }

  function drawMidpointGuides() {
    if (!els.guides) return;

    const mx = stage.w / 2;
    const my = stage.h / 2;

    const unit = (els.units && els.units.value) ? els.units.value : "ft";
    const midW = pxToUnits(mx);
    const midH = pxToUnits(my);

    els.guides.innerHTML = `
    <!-- crosshair -->
    <line x1="${mx}" y1="0" x2="${mx}" y2="${stage.h}"
      stroke="rgba(0,0,0,0.10)" stroke-width="2" stroke-dasharray="8 8" />
    <line x1="0" y1="${my}" x2="${stage.w}" y2="${my}"
      stroke="rgba(0,0,0,0.10)" stroke-width="2" stroke-dasharray="8 8" />

    <!-- midpoint labels -->
    <text x="${mx}" y="22" text-anchor="middle"
      fill="rgba(0,0,0,0.65)" font-size="14"
      stroke="white" stroke-width="6" paint-order="stroke">
      Mid: ${fmt1(midW)} ${unit}
    </text>

    <text x="14" y="${my}" text-anchor="start" dominant-baseline="middle"
      fill="rgba(0,0,0,0.65)" font-size="14"
      stroke="white" stroke-width="6" paint-order="stroke">
      Mid: ${fmt1(midH)} ${unit}
    </text>
  `;
  }

  function svgEl(tag) { return document.createElementNS("http://www.w3.org/2000/svg", tag); }

  function uid() { return "it_" + Math.random().toString(16).slice(2); }

  function clampf(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function round2(n) { return Math.round(n * 100) / 100; }

  function mod(n, m) { return ((n % m) + m) % m; }

  function num(v, fallback) {
    const n = typeof v === "number" ? v : parseFloat(v);
    return Number.isFinite(n) ? n : fallback;
  }

  function deepClone(obj) {
    if (typeof structuredClone === "function") return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
  }

  function transformPoint(x, y, m) {
    return { x: m.a * x + m.c * y + m.e, y: m.b * x + m.d * y + m.f };
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }
  function escapeXml(s) {
    return String(s).replace(/[&<>"]/g, m => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;" }[m]));
  }
  function escapeAttr(s) { return escapeHtml(s).replace(/"/g, "&quot;"); }

  function toColorInput(v) {
    // Accept '#rrggbb' or rgb/rgba. If rgba, just return black-ish fallback.
    const s = String(v || "").trim();
    if (/^#[0-9a-fA-F]{6}$/.test(s)) return s;
    if (/^#[0-9a-fA-F]{3}$/.test(s)) {
      return "#" + s[1] + s[1] + s[2] + s[2] + s[3] + s[3];
    }
    // if rgba(...) parse first 3
    const m = s.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)(?:\s*,\s*([0-9.]+))?\s*\)/i);
    if (m) {
      const r = clampf(parseInt(m[1],10),0,255);
      const g = clampf(parseInt(m[2],10),0,255);
      const b = clampf(parseInt(m[3],10),0,255);
      return "#" + [r,g,b].map(n => n.toString(16).padStart(2,"0")).join("");
    }
    return "#111111";
  }

  function cssEscape(str) {
    if (window.CSS && CSS.escape) return CSS.escape(str);
    return String(str).replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
  }

  // ============================================================
  // INIT
  // ============================================================
  // set W/H inputs from current stage in current units
  if (els.w) els.w.value = String(round2(pxToUnits(stage.w)));
  if (els.h) els.h.value = String(round2(pxToUnits(stage.h)));

  if (els.gridBtn) {
    els.gridBtn.textContent = `Grid: ${stage.showGrid ? "On" : "Off"}`;
    els.gridBtn.setAttribute("aria-pressed", stage.showGrid ? "true" : "false");
  }
  if (els.cableModeBtn) {
    els.cableModeBtn.setAttribute("aria-pressed", "false");
    els.cableModeBtn.textContent = "Cable Tool: Off";
  }

  renderLibrary("");
  loadExternalIconSvgs().then(() => {
    renderLibrary(els.search ? els.search.value : "");
    draw();
  });
  pushHistory("init", true);
  draw();
  root.focus();
})();

</script>
